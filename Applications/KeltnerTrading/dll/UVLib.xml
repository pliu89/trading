<?xml version="1.0"?>
<doc>
    <assembly>
        <name>UVLib</name>
    </assembly>
    <members>
        <member name="T:UV.Lib.Application.AppInfo">
            <summary>
            This singleton model object contains only the most basic information necessary
            for the application to run.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.AppInfo.RequestShutdown(System.Object,System.EventArgs)">
            <summary>
            To use this, the main application object (usually the main form) must
            add itself to the private m_RequestApplicationShutdown delegate using
            the method below.
            </summary>
            <param name="sender"></param>
            <param name="eventArg"></param>
        </member>
        <member name="T:UV.Lib.Application.AppServiceEventArg">
            <summary>
            </summary>
        </member>
        <member name="T:UV.Lib.Application.AppServices">
             <summary>
             The first caller to GetInstance() in this class must be the UI thread.
             If AppServices are to be used, then this will create an AppInfo object.
             Example Usage:
                 typeof(Ambre.TTServices.Markets.MarketTTAPI).ToString();            // force needed assemblies to load.
                 AppServices appServices = AppServices.GetInstance("appName", true); // Set application information - do this before hubs are instantiated.
                 appServices.Info.RequestShutdownAddHandler(new EventHandler(this.RequestShutdownHandler)); // let main form know about shutdown requests
                 appServices.LoadServicesFromFile("ConfigFile.txt");                 // Stringifications for all services.
            
                 appServices.Start();                                                // Start thread hubs.
                 appServices.Connect();                                              // Start connection to external world, like APIs etc.
             </summary>
        </member>
        <member name="M:UV.Lib.Application.AppServices.#ctor">
            <summary>
            The constructor must be called by the UI thread. Therefore, the UI thread
            must call GetInstance() creator the first time.  Afterwards, any thread can
            can call GetInstance().
            Alternative: use PresentationFramework Application.Current.Dispatcher?
            </summary>
        </member>
        <member name="M:UV.Lib.Application.AppServices.GetInstance(System.String,System.Boolean)">
            <summary>
            If AppServices is to be used, it must be called before AppInfo.
            </summary>
            <param name="applicationName"></param>
            <param name="isExactDirName"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.GetInstance">
            <summary>
            This is the usual overloading that is called once the application
            has started.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.TryCreateSoloInstance">
            <summary>
            New approach creates AppServices instance, and confirms that only ONE instance
            of this application is running.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.TryAddService(System.Object)">
            <summary>
            Tries to add a service object to the appropriate service list.
            Will ensure the name is unique.
            </summary>
            <param name="serviceObject"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.TryShutdownService(System.String)">
            <summary>
            Attempt to remove a specific service.  If found, its immediately removed from 
            the service list, and requested to stop. Its immediate removal guarantees that
            we can immediately save the config file for the Services.
            </summary>
            <param name="serviceNameToRemove"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.TryLoadServicesFromFile(System.String)">
            <summary>
            Creates all services according to XML in config file.
            </summary>
            <param name="configFileName"></param>
        </member>
        <member name="M:UV.Lib.Application.AppServices.GetServices(System.Type)">
            <summary>
            Allow users to get all services of a certain type, or service name.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.GetServices">
            <summary>
            Returns all active services.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.TryGetService(System.String,UV.Lib.Application.IService@)">
            <summary>
            Returns service with exact service name, or returns false.
            </summary>
            <param name="serviceName"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.GetServiceNames">
            <summary>
            Returns all service names 
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.AppServices.Start">
            <summary>
            TODO: Services like the hubs, that are managed services should all have to 
            implement a single interface that implements these state requests:  Start(), 
            Connect(), RequestStop(), etc.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.AppServices.RequestShutdownHandler(System.Object,System.EventArgs)">
            <summary>
            Respond to someone requesting a shutdown of the application by shutting 
            down services nicely.
            TODO: I think this feature should be within this object not AppInfo.
            </summary>
            <param name="sender"></param>
            <param name="eventArg"></param>
        </member>
        <member name="M:UV.Lib.Application.AppServices.Service_Stopping(System.Object,System.EventArgs)">
            <summary>
            When I request a service to shutdown, I also attach myself to its Stopping event
            and expect to hear back from it.  Upon receiving, the service is removed from 
            the ServicesRemoved list.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="E:UV.Lib.Application.AppServices.ServiceStopped">
            <summary>
            Triggered when a Service has stopped and it has been removed from our ServiceList.
            </summary>
        </member>
        <member name="E:UV.Lib.Application.AppServices.ServiceAdded">
            <summary>
            Triggered when a Service is added to our ServiceList.
            </summary>
        </member>
        <member name="T:UV.Lib.Application.ExceptionCatcher">
            <summary>
            Some encapsulated code for exception processing.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.ExceptionCatcher.QueryUserTakeAction(System.Exception,UV.Lib.Hubs.Hub,System.String,System.EventArgs)">
            <summary>
            Opens a form asking the user whether exception should be retried or ignored.
            </summary>
            <param name="exceptionThrown">thrown exception object</param>
            <param name="hub">hub that experienced exception</param>
            <param name="userMessage">optional user text for message</param>
            <param name="eventThatFailed"></param>
            <returns>DialogResult selected by user.</returns>
        </member>
        <member name="M:UV.Lib.Application.ExceptionCatcher.QueryUserTakeAction(System.Exception,UV.Lib.Hubs.Hub,System.EventArgs)">
            <summary>
            Simple over-loading useful for Hub objects.
            </summary>
            <param name="exceptionThrown">thrown exception</param>
            <param name="hub">hub that experienced exception</param>
            <param name="eventThatFailed">event that we were processing when the exception was thrown.</param>
            <returns>>DialogResult selected by user.</returns>
        </member>
        <member name="M:UV.Lib.Application.ExceptionCatcher.QueryUser(System.Exception,System.String)">
            <summary>
            Opens a form asking the user whether exception should be retried or ignored.
            </summary>
            <param name="exceptionThrown">thrown exception object</param>
            <param name="userMessage">Optional text containing information about what failed.</param>
            <returns>DialogResult selected by user.</returns>
        </member>
        <member name="M:UV.Lib.Application.ExceptionCatcher.QueryUser(System.Exception,System.EventArgs)">
            <summary>
            Simple over-loading useful for Hub objects.
            </summary>
            <param name="exceptionThrown">thrown exception</param>
            <param name="eventThatFailed">event that we were processing when the exception was thrown.</param>
            <returns>>DialogResult selected by user.</returns>
        </member>
        <member name="T:UV.Lib.Application.IService">
            <summary>
            A Service represent an application resource that receives requests and processes
            them asynchronously.  
            This services are usually autonomous, being created via a deserialization process and
            will spontaneously appear as a new service held by the Application.AppServices singleton object.
            Application.AppServices manages them assuming they at IService objects.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.IService.Start">
            <summary>
            The life cycle of a service begins with Start().  
            This begins the service's internal initialization.  It assumes that all other services
            (that it may need) have been created, but are not neccessarily running yet.
            Note that many services will depend on others (that is, require that another service exists) 
            to work properly.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.IService.Connect">
            <summary>
            After being started, the service is asked to Connect().
            Here, it is allowed to connect to the outside world, and upon completing
            this phase, it triggers the Connected event.  Announcing that it is fully operational.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.IService.RequestStop">
            <summary>
            Initiates the shutdown process.
            </summary>
        </member>
        <member name="E:UV.Lib.Application.IService.ServiceStateChanged">
            <summary>
            Services should trigger this event whenever their state changes.
            And are expected to pass a ServiceStateEventArgs instance.
            </summary>
        </member>
        <member name="E:UV.Lib.Application.IService.Stopping">
            <summary>
            Services should trigger this event whenever their state changes.
            And are expected to pass a ServiceStateEventArgs instance.
            </summary>
        </member>
        <member name="T:UV.Lib.Application.Managers.ForeignConnection">
            <summary>
            A description of how to connect to a foreign server, their location 
            and configuration.
            </summary>
        </member>
        <member name="T:UV.Lib.Application.Managers.ForeignEngineHub">
            <summary>
            A place holder for a IEngineHub Service located on a foreign server.
            </summary>
        </member>
        <member name="T:UV.Lib.Application.Managers.ForeignService">
            <summary>
            A description of a single service located on a foreign server.
            </summary>
        </member>
        <member name="T:UV.Lib.Engines.IEngineHub">
            <summary>
            An object that contains a list of IEngineContainers.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.IEngineHub.OnEngineChanged(System.EventArgs)">
            <summary>
            Usually, this would be a private function.  However, in the multithreading model 
            for individual strategy (as in Execution framework), its convenient for each 
            strategy to call this method directly themselves.
            </summary>
            <param name="engineEventArgs"></param>
        </member>
        <member name="T:UV.Lib.Application.Managers.ForeignServer">
            <summary>
            </summary>
        </member>
        <member name="M:UV.Lib.Application.Managers.ForeignServer.TryAddService(UV.Lib.Application.Managers.ForeignService)">
            <summary>
            This ForeignServer will try to register this ForeignSerivce with AppServices.
            It will try to create a new LocalServiceName = "Remote Service Name" + "@" + "ServerId"
            so that it will be unique in the *local* application service list.
            </summary>
            <param name="foreignService"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.Application.Managers.Message">
            <summary>
            Message object sent thru sockets providing communication between Application managers.
            </summary>
        </member>
        <member name="T:UV.Lib.Application.Managers.MessageType">
            <summary>
            Type of message object
            </summary>
        </member>
        <member name="T:UV.Lib.Application.Managers.RequestCode">
            <summary>
            Request codes for the Service Managers
            </summary>
        </member>
        <member name="T:UV.Lib.Application.Managers.ServiceManager">
            <summary>
            This object mananges communication between local services 
            registered in the AppServices object, and those of another
            instance located on a foreign location.
            To acheive this it connects to other ServiceManagers via a
            socket.
            </summary>
        </member>
        <member name="T:UV.Lib.Hubs.Hub">
            <summary>
            This class should be inherited by all "hubs."  
            This class inherits from the HubBase which maintains a private thread for the hub
            along with an associated "wait handle" and event queue.  It also provides some other 
            support features, such as a log.
            Example of usage:
            Class inheritance structure:    HubBase -- Hub -- MarketHub -- MarketSimAPI
            Usually an API-specific event is triggered somehow (from the exchange server API) at 
            the highest level, which is a sub-class of a sub-class (in this example the sub-sub-class 
            is the "MarketSimAPI").
            The API-specific event is interpreted by MarketSimAPI and the appropriate MarketHub.MarketHubEvent 
            is created and loaded into HubBase.HubEventEnQueue( MarketHubEvent ), which wakes up its 
            private HubBase thread to process the event.  
            The processing is done by calling HubEventHandler() which MUST be overriden by the intermediate
            sub-class (called "MarketHub" here).  The internal state of MarketHub is then changed in accordance
            with the event and it informs whatever objects have subscribed to its public events, such as 
            "PriceChange" or "EchangeStateChange" etc.
            Purpose of the Hub and HubBase classes:
            The purpose of this round-about way of doing things is few-fold: 
            First: 
            API-specific information is only located in the sub-sub-class MarketSimAPI, 
            while application specific info lives in the subclass MarketHub.  In this way, API-specific
            stuff (inside MarketSimAPI) does not appear in the class in change of the local 
            application (MarketHub).
            Second: 
            The Hub and HubBase classes are solely responsible for thread control and management.
            Third:
            The initial event is passed to MarketSimAPI from an external thread, the event is quickly
            pushed onto a queue and later processed by the local HubBase thread.  This frees up the 
            original thread to return to the API as soon as possible.
            </summary>
        </member>
        <member name="T:UV.Lib.Hubs.HubBase">
            <summary>
            This class should be inherited by all "hubs."  
            This hub base maintains a private thread for the hub along with an associated
            "wait handle" and event queue.  
            
            For a complicated example of usage: See class "Hub.cs"
            
            Simple Usage:
            Consider an application for logging messages to a file.  Here, one might have simply
            two classes
                        LogHub >> HubBase
            
            Message logging starts when an external thread from the main application (called main thread)
            passes a new msg string into a method called, say, LogHub.NewMessage( string ).  
            In this method (called by main thread) the string is re-packaged into an EventArg object 
            and passed to the HubBase via HubBase.EnQueue( EventArg ).  The main thread is then free
            to exit.
            Thereafter, the HubBase thread awakens and passes the eventArg back up to 
            Logger.HubEventHandler( EventArg ) which unpacks the string message, and processes it.
            All of this work is done by the HubBase thread of course.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="hubName">Generic name for hub. Used to name thread, and log files, etc. 
            Can be changed later.
            </param>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.Start">
            <summary>
            Called by main thread, it is here that we might finalize any form/gui
            owned by this hub.  Also creates the hub's thread by invoking WaitListenStart().
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.Stop">
            <summary>
            Called by any external thread, this attempts a friendly shut-down of the hub listener.
            When this is overloaded by another class, it should call this base method also!!
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.HubEventEnqueue(System.EventArgs)">
            <summary>
            Called an external thread, this method is usually called by the 
            api-specific sub-sub-class to load new events and then wake the Hub thread to 
            process them.
            This is where the shared HubEventQueue are accessed by the external threads.
            </summary>
            <param name="e"></param>
            <returns>Returns true if event is successfully triggered.</returns>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.HubEventEnqueue(System.EventArgs[])">
            <summary>
            Overloading that allows for multiple events to be send simultaneously.
            </summary>
            <param name="e"></param>
            <returns>Returns true if event is successfully triggered.</returns>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.HubEventEnqueue(System.Object,System.EventArgs)">
            <summary>
            This overloading is of the general EventHandler form.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.TriggerEvent">
            <summary>
            This is called by an external (or internal) thread.  Its calls Set() for the
            internal (or local) HubBase thread that is sleeping.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.WaitListenStart">
            <summary>
            Any actions that are to be performed by the hub thread immediatedly
            before it first enters the WaitListen() method can be implememented here
            by overriding this method. Overloading method must finally call this method at end.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.WaitListen">
            <summary>
            This method is owned by the hub thread only.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.UpdatePeriodicCheck">
            <summary>
            Checks whether enough time has passed to require a call to PeriodicUpdate().
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.UpdateDiagnostics">
            <summary>
            Updates average load calculations and other diagnostics.  Resets StopWatch.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.DiagnosticReport">
            <summary>
            Inheriting classes should override this and read the above diagnostic variables.
            
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.HubEventHandler(System.EventArgs[])">
            <summary>
            This method should be overrided by the sub-class otherwise, events that 
            are received by this HubBase will be sent into this method and into oblivion.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.UpdatePeriodic">
            <summary>
            This method may be implemented by a sub-class if there are periodic tasks
            to be performed in that class.  The period may set.
            The implementation of this is optional.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.HubBase.Finalizing">
            <summary>
            This is called by the internal hub thread, just after it falls out the bottom
            of the WaitListen() loop, immediately prior to dying forever.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.Hub.#ctor(System.String)">
            <summary>
            Simplified hub constructor.  If this form is used, the subclass MUST directly create the LogHub!  
            </summary>
            <param name="hubName"></param>
        </member>
        <member name="M:UV.Lib.Hubs.Hub.DiagnosticReport">
            <summary>
            This overrides the empty HubBase method and logs the important statistics.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.SendMessage(System.Int32,UV.Lib.Application.Managers.Message)">
            <summary>
            Simple method to send a Message to a specific ServiceManager
            on a specific socket conversation.  
            </summary>
            <param name="conversationId">Conversation to send message on, -1 means all conversations.</param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.SendServices(System.Int32,UV.Lib.Application.Managers.MessageType,System.Collections.Generic.List{UV.Lib.Application.IService})">
            <summary>
            Sends Messages specific to the addition/removal of 
            local services.  These messages are broadcast to all
            currently connected servers.
            TODO: Perhaps we need only broadcast to those connections
            that initiated the connection?
            </summary>
            <param name="conversationId"></param>
            <param name="msgType"></param>
            <param name="iServiceList"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ProcessRequestServiceState(UV.Lib.Utilities.RequestEventArg{UV.Lib.Application.Managers.RequestCode})">
            <summary>
            Internal or external requests for this object to change its
            own state, states like Started, Running, and Stopped.
            Some states need to make sure certain features are running before
            they allow us to proceed to another state.
            Intialization is triggered here.
            </summary>
            <param name="requestEventArg"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ProcessRequestServerConnect(UV.Lib.Utilities.RequestEventArg{UV.Lib.Application.Managers.RequestCode})">
            <summary>
            This processes the local request to connect to a foreign server via a socket.
            Requirements:
                Request.Data = {ForeignConnection,
            </summary>
            <param name="requestEventArg"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ForeignServerConnect(UV.Lib.Application.Managers.ForeignServer,System.Int32)">
            <summary>
            Called when a ForeignServer is connected (or re-connected) to its remote
            via a new Conversation.
            </summary>
            <param name="fs"></param>
            <param name="newConversationId"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ForeignServerDisconnect(UV.Lib.Application.Managers.ForeignServer)">
            <summary>
            When a conversation ends, the associated ForeignServer is moved
            to the disconnected list.  Its conversation ID is set to -1.
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ProcessSocketEvent(UV.Lib.Sockets.SocketEventArgs)">
            <summary>
            First stop in processing incoming socket messages.  
            Here, we split them by "event type" and those of type "MessageReceived" 
            are decoded, processed by ProcessRequestMessage() or ProcessConfirmMessage().
            </summary>
            <param name="eventArg"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ProcessMessageRequests(UV.Lib.Sockets.SocketEventArgs,UV.Lib.Application.Managers.Message)">
            <summary>
            These are Messages that originated from foreign servers.  
            </summary>
            <param name="eventArg"></param>
            <param name="msg"></param>
        </member>
        <member name="M:UV.Lib.Application.Managers.ServiceManager.ProcessEngineEvent(UV.Lib.Engines.EngineEventArgs)">
            <summary>
            These come from engine hub confirmations.
            </summary>
            <param name="eventArg"></param>
        </member>
        <member name="T:UV.Lib.Application.RunType">
            <summary>
            This describes the various modes in which the application can be run.
            </summary>
        </member>
        <member name="T:UV.Lib.Application.ServiceStateEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:UV.Lib.Application.ServiceStateEventArgs.#ctor">
            <summary>
            Private means this is disabled and users must call other constructor.
            </summary>
        </member>
        <member name="M:UV.Lib.Application.ServiceStateEventArgs.#ctor(UV.Lib.Application.IService,UV.Lib.Application.ServiceStates,UV.Lib.Application.ServiceStates)">
            <summary>
            The constructor that ensures the proper creation of the eventArgs.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.Book.CopyTo(UV.Lib.BookHubs.Book)">
            <summary>
            After the book hub obtains the write lock for the next writable book, 
            it can copy this book to that one.  
            Note: In practice, it doesn't need to get a read lock on this book, if 
            its the only thread that can get a write lock.
            Called by the BookHub only.
            </summary>
            <param name="aWriteLockedBook">A book already locked for writing</param>
        </member>
        <member name="T:UV.Lib.BookHubs.BookHub">
            <summary>
            This class is a hub that manages and updates books for multiple readers (on different threads).
            Only the local hub thread is allowed to write to these books. Many readers, but a single writer thread.
            Usage:
                Each Book contains multiple instruments each accessed by an ID#.
                Users subscribe to InstrumentChanged event, which returns the instr ID#s that changed.
            Internal procedure: 
                This hub manages a collection of duplicate books.  Only one book is designated
            as the "current" or "published" book at any given moment that is accessible to the many readers.
            As new events come in, if the "current" or published book is being read by another thread,
            then the next book in the collection is updated and prepared, and then published, 
            with events sent out to subscribers to look at the new current book.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.TryEnterReadBook(UV.Lib.BookHubs.Book@)">
            <summary>
            Requests a read lock on the current book and receives a pointer to it.
            Called by an external thread.
            </summary>
            <returns>Current book object.</returns>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.ExitReadBook(UV.Lib.BookHubs.Book)">
            <summary>
            Returns the read-lock for this book.  This should be called as soon
            as the reader no longer needs to read the book.
            Called by an external thread.
            </summary>
            <param name="aBook">Book to release lock.</param>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.AddInstrumentToBook(UV.Lib.BookHubs.Market)">
            <summary>
            Adds an additional instrument to the next writable book.
            Called by local bookhub thread.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.EnterWriteLock">
            <summary>
            Called by local bookhub thread.   Returns the next book that is free for
            the Writer thread (me).
            </summary>
            <returns>ID book available for updating.</returns>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.ExitWriteLock(System.Int32)">
            <summary>
            Release the currently writer-locked book.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.CreateNewBook">
            <summary>
            Creates a new book and gets a writer lock on it.  The lock is obtained
            prior to making its existance public to avoid any race condition.
            Called by the hub thread.
            </summary>
            <returns>ID of new book.</returns>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.ProcessBookEvents(System.Collections.Generic.List{System.EventArgs})">
            <summary>
            Once an event in the queue is determined to be a market change event, or
            any event changing the "market book" of an instrument, this method is 
            called to update the market instrument books.
            Called by hub thread only.  
            </summary>
            <param name="eArgList">A list of market change events.</param>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.BringBookUpToDate(System.Int32)">
            <summary>
            Version 1:
            Example: Assume 3 books, current book is #2, and new events "F" come in to system.  
                GetNextBookLock() will return either #2 (if no one currently looking at it) or #3.
                Book ID:        1           2           3
                eventList:      D           E           C  
                currentBook:                *
                
                CASE 1: 
                0.0 GetNextUpdateBook ---> updatebook = 3, which is not the current book.
                1.0 stopAtBook = current + 1  ---> "3"
                2.1 (updateBook+1) ---> "1", so process(events#1 = D)
                2.2 (updateBook+2) ---> "2", so process(events#2 = E)
                2.3 (updateBook+3) ---> "3", is the stopAtBook, so stop.
                3.0 process new events "F".
                4.0 if ( currentBook != updateBook ) clear events in updateBook (delete C).
                5.0 Add "F" to events#3.
                6.0 Publish book.
                CASE 2: 
                0.0 GetNextUpdateBook --->  updateBook = 2, which IS the currentBook!    
                1.0 stopAtBook = current + 1 ---> "3"
                2.1 (updateBook+1) ---> "3", is the stopAtBook, so stop.
                3.0 process new events "F".
                4.0 since ( currentBook == updateBook ) don't clear events in updateBook (don't delete E)
                5.0 Add "F" to events#2 (updateBook events)
                6.0 Publish book.
            Version 2:
                If the current != updateBook, copy all mkt values to updateBook.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.ProcessBookEventsForABook(System.Int32,System.Collections.Generic.List{System.EventArgs})">
            <summary>
            Give a particular book ID, and the events, this abstract method actually does the 
            book updating.  As this is dependent on both the detailed form of the messages in 
            the events AND the particular type of instrument in the book, it must be implemented
            by the super class.
            </summary>
            <param name="bookID"></param>
            <param name="eArgList"></param>
            <returns>InstrumentChangeArgs list of changed instruments</returns>
        </member>
        <member name="M:UV.Lib.BookHubs.BookHub.OnInstrumentChange(UV.Lib.BookHubs.InstrumentChangeArgs)">
            <summary>
            Here, we already have the event object (perhaps someone else created it).  Before
            triggering event, we mark that we are the senders, but note, if someone else created
            it, "CustomEventCreator" could be a different object (say, the object that requested
            something from this book). 
            </summary>        
        </member>
        <member name="M:UV.Lib.BookHubs.MarketBase.GetChangedDepth">
            <summary>
            Finds first changed depth by side handing caller back array indexed 
            by market side
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.BookHubs.MarketBase.Clear">
            <summary>
            Called to clean out list of changed indices prior to recycling or before use.
            This is essential to ensuring corrected price updates.
            
            If this is done properly none of the other arrays need to be cleared out, since
            they will be overwritten during the update process correctly.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.MarketBase.ClearVolume">
            <summary>
            Called if the market bases volume by side needs to be updated, this allows for volume to be aggregated
            correctly since often many trades come in at the same time. Since we reset to zero, we can them
            simply sum all the volume for a block of trades by side.
            </summary>
        </member>
        <member name="T:UV.Lib.BookHubs.InstrumentChangeArgs">
            <summary>
            This event arg is launched from the BookHub whenever one of its book changes.
            It is this event that a typical trading strategy will received from the MarketHub.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.InstrumentChangeArgs.#ctor">
            <summary>
            This constructor allows the caller to create an empty InstrumentChangeArgs and
            call AppendChangedInstrument as well as assign sender after construction.
            </summary>
        </member>
        <member name="T:UV.Lib.BookHubs.Market">
            <summary>
            This object represents a single market for a particular Instrument.
            </summary>
        </member>
        <member name="M:UV.Lib.BookHubs.Market.SetMarket(UV.Lib.BookHubs.MarketBase)">
            <summary>
            </summary>
            <param name="marketBase"></param>
        </member>
        <member name="M:UV.Lib.BookHubs.Market.SetMarket(System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Called to update the maket depth for one side of the market, for one level.
            Currently, volume and trade information is updated by hand, there is no 
            method call for volume/trades.
            </summary>
            <param name="mktSide"></param>
            <param name="level"></param>
            <param name="price"></param>
            <param name="qty"></param>
            <param name="TotalVolume"></param>
            <param name="impliedQty"></param>
        </member>
        <member name="M:UV.Lib.BookHubs.Market.SetMarket(UV.Lib.BookHubs.Market)">
            <summary>
            This is the "copy" over-loading of SetMarket()
            </summary>
            <param name="instr"></param>
        </member>
        <member name="F:UV.Lib.BookHubs.Market.MarketChanged">
            <summary>
            Event called anytime a tick occurs within the depth we currently care 
            about.
            </summary>
        </member>
        <member name="F:UV.Lib.BookHubs.Market.MarketBestPriceChanged">
            <summary>
            Event called anytime a top of book price change occurs
            about.
            </summary>
        </member>
        <member name="T:UV.Lib.BookHubs.MarketUpdateEventArgs">
            <summary>
            This 
            </summary>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.ExchangeInfoQuery">
            <summary>
            This class is a query object that will load the entire ExchangeInfo table
            into a list of ExchangeInfoItems (one for each row entry in table).
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.QueryBase.GetQuery(UV.Lib.DatabaseReaderWriters.DatabaseInfo)">
            <summary>
            Returns the query string that should be executed to the mysql command.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.QueryBase.GetWriteQueryPrefix(UV.Lib.DatabaseReaderWriters.DatabaseInfo)">
            <summary>
            Returns the string that would be the "prefix" of the mysql command. Everything from "INSERT" and to "VALUES"
            Useful for query aggregation
            </summary>
            <param name="databaseInfo"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.QueryBase.GetWriteQuerySuffix(UV.Lib.DatabaseReaderWriters.DatabaseInfo)">
            <summary>
            Returns the string that would be the "suffix" of the mysql command. Everything after "VALUES" and before ";"
            Useful for query aggregation
            </summary>
            <param name="databaseInfo"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.QueryBase.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            This is the function that accepts the data from the DatabaseReaderWriter object, 
            and casts it into
            </summary>
            <param name="databaseInfo"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.ExchangeInfoItem">
            <summary>
            Small object to hold a row from the ExhangeInfo
            </summary>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.FillsQuery">
            <summary>
            Query for writing reading to the Fills table.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.FillsQuery.AddItemToWrite(System.Int32,System.Int32,System.DateTime,UV.Lib.Application.UserInfo,System.String,System.String,System.Int32,System.Double)">
            <summary>
            User calls this function to add a new signal item for later writing.
            TODO: 
                1) this is written like this so in future, we can recycle signal items
                    without the user having access to them.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.FillsQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="dbInfo"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.FillsQuery.GetWriteQuery(UV.Lib.DatabaseReaderWriters.DatabaseInfo)">
            <summary>
            Caller would like to get a fully formed query to insert into database.
            </summary>
            <param name="dataBase"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.InstrumentInfoQuery">
            <summary>
            Notes:
                1) Currently this only pulls rows base on instrument names that are TT-like.
                    To improve this, simpy have a flag that allows us to use Reuters names, TT names or whatever.
                    Alternatively, this object can call multiple InstrumentDetails, one for each TT, Reuters, etc.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.InstrumentInfoQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="dbInfo"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.EconomicDataQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="database"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.EconomicDataItem">
            <summary>
            </summary>
        </member>
        <member name="P:UV.Lib.DatabaseReaderWriters.Queries.EconomicDataItem.TimeStamp">
            <summary>
            DateTime in LOCAL TIME!
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.MarketDataQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="database"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter">
            <summary>
            This is a hub that provides on-demand services to read/write to database.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.#ctor(UV.Lib.DatabaseReaderWriters.DatabaseInfo)">
            <summary>
            Simplified auto-starting constructor used by applications that just want
            to create a single DatabaseReaderWriter and use it.  No need to call "Start()"
            </summary>
            <param name="dbInfo"></param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.#ctor">
            <summary>
            IStringifiable constructor.  After construction, this object will 
            remain unstarted until Start() is called explicity.  Before this, m_Database MUST be set.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.SubmitAsync(UV.Lib.DatabaseReaderWriters.Queries.QueryBase)">
            <summary>
            This is the asynchronous query.  The requesting thread is
            immediately released after pushing the query request onto the 
            hub queue, and call back is made with a QueryResponse event.
            The results as placed withing the query object, so the calling 
            thread should not keep it.
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.SubmitSync(UV.Lib.DatabaseReaderWriters.Queries.QueryBase)">
            <summary>
            Here, the query is made synchronously and the requesting
            thread waits until the query is completed, the results are
            added to the query and returned to the calling thread.
            No event is triggered in this case.
            
            NOTE: This only works correctly with read queries. Write queries are always queued.
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.HubEventHandler(System.EventArgs[])">
            <summary>
            This is the main processing routine.
            </summary>
            <param name="eventArgsList"></param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.TryProcessWriteQueryString(System.String,MySql.Data.MySqlClient.MySqlConnection)">
            <summary>
            Caller would like to attemp to wite a query string to the connection provided.
            </summary>
            <param name="queryString"></param>
            <param name="mySqlConnection"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.UpdatePeriodic">
            <summary>
            Called periodically to check state and if we have pending queries to write.
            
            Note: For this to work every query object must correctly override base class methods for Suffix and Prefix
            </summary>
        </member>
        <member name="E:UV.Lib.DatabaseReaderWriters.DatabaseReaderWriter.NonQueryResponse">
            <summary>
            This provides only write success/failure responses for non query 
            transactions.
            </summary>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.MarketDataItem">
            <summary>
            </summary>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.ProductInfoQuery">
            <summary>
            This is a query object to load the entire ProductInfo table 
            into a list of ProductInfoItems (one for each row).
            </summary>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.ProductInfoItem">
            <summary>
            Small object to hold a row from the ProductInfo table.
            </summary>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.SignalQuery">
            <summary>
            Query for writing reading to the Signals table.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.SignalQuery.AddItemToWrite(System.Int32,System.Int32,System.DateTime,UV.Lib.Application.UserInfo,System.String,System.Int32,System.Int32,System.Double)">
            <summary>
            User calls this function to add a new signal item for later writing.
            TODO: 
                1) this is written like this so in future, we can recycle signal items
                    without the user having access to them.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.SignalQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="dbInfo"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.StrategiesQuery">
            <summary>
            Query for reading the Strategies table.
            Notes:
                1) in future, we may want to allow different sorts of queries, by groupId or dates for example.
                    These can be implemented using different constructors.
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.StrategiesQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="dbInfo"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.DatabaseReaderWriters.Queries.StrategyEnginesQuery">
            <summary>
            Query for reading the Strategy Engines table.
            Notes:
            </summary>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.StrategyEnginesQuery.#ctor(System.Int32)">
            <summary>
            Creates query to get all engines associated with SINGLE strategyId.
            </summary>
            <param name="strategyId"></param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.StrategyEnginesQuery.#ctor(System.Collections.Generic.List{System.Int32})">
            <summary>
            Creates query to get all engines associated with LIST of strategy Id numbers.
            </summary>
            <param name="strategyIdList">List of strategy Ids.</param>
        </member>
        <member name="M:UV.Lib.DatabaseReaderWriters.Queries.StrategyEnginesQuery.AcceptData(UV.Lib.DatabaseReaderWriters.DatabaseInfo,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="dbInfo"></param>
            <param name="values"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.SendEmailMessage(System.String,System.String)">
            <summary>
            This method provides a simple way to send emails, constructing the appropriate
            DBWRequest object for a send email request.
            </summary>
            <param name="subject"></param>
            <param name="aMsg"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.InsertIntoTable(System.String,System.Collections.Generic.Dictionary{System.String,System.String}@,System.String@)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="data">Dictionary object loaded directly into event.  Not affected by this routine.</param>
            <param name="logMessage"></param>
            <returns>String of outgoing query, suitable to add to your log.</returns>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.ExecuteNonQuery(System.String)">
            <summary>
            User has provided a non-query command for us to process.  We do nothing but
            send off his request.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.SendEmailNow">
            <summary>
            This method compiles all the messages intended 
            </summary>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.GetEventArg">
            <summary>
            The most-basic DBWRequests event arg is passed back to the caller.
            It is assumed to be of type database "Write".
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.WriteNow">
            <summary>
            Here we do actual writing the data to the database.
            </summary>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.ProcessFailedQueries">
            <summary>
            Queries in the FailQueriesQueue have failed to be written in the past.
            It might have been they that threw the write exception, or another query.
            Here, we try to write them again.  If they fail several more times, they are pushed
            onto the Chronic queue for later study.
            </summary>
        </member>
        <member name="M:UV.Lib.Database.DatabaseWriterHub.ProcessChronicQueries">
            <summary>
            These queries have failed many times already.  There are many possible reasons.
            This method will make some attempt to correct these reasons, otherwise write these
            chronic queries to a file for the user to figure out later.
            </summary>
        </member>
        <member name="T:UV.Lib.Database.ExchangeNameToID">
            <summary>
            Currently unused.  This class was originally going to be a way of getting
            mySQL exhange ID's.  
            </summary>
        </member>
        <member name="T:UV.Lib.Database.DBInstrument">
            <summary>
            Class for reading instruments from a UV style database.
            </summary>
        </member>
        <member name="M:UV.Lib.Database.DBInstrument.TryCheckMySQLInstrumentDetails(UV.Lib.Database.DatabaseInfo,UV.Lib.Products.InstrumentDetails,System.String@)">
            <summary>
            Try to find an instrument in the database, check it's data, and if 
            incorrect or missing fill in with new data.
            
            </summary>
            <param name="dataBase"></param>
            <param name="instrDetails"></param>
            <param name="queryToExecute">will return non empty string to be pushed to db writer if data in the table needs to be written</param>
            <returns>true if instrument was found and checked</returns>
        </member>
        <member name="M:UV.Lib.Database.DBInstrument.TryGetMySQLInstrumentId(UV.Lib.Database.DatabaseInfo,UV.Lib.Products.InstrumentName,System.Int32@)">
            <summary>
            Try and find the uniquie Instrument ID from a mySQL database for a given InstrumentName.
            </summary>
            <param name="dataBase"></param>
            <param name="instrument"></param>
            <param name="mySQLInstrumentID"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Database.DBInstrument.TryReadMySQLInstrumentID(MySql.Data.MySqlClient.MySqlDataReader,System.Int32@)">
            <summary>
            Helper function to read a instrument ID from a database.
            </summary>
            <param name="reader"></param>
            <param name="mySQLInstrumentID"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Database.DBInstrument.TryReadInstrumentDetails(MySql.Data.MySqlClient.MySqlDataReader,System.Double@,System.Double@,System.Double@,System.Double@,System.DateTime@)">
            <summary>
            Helper function for reading instrument details from a instrumentTable.
            </summary>
            <param name="reader"></param>
            <param name="unitTT"></param>
            <param name="tickTT"></param>
            <param name="smallTickTT"></param>
            <param name="calendarTickTT"></param>
            <param name="expirationDate"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.Database.DBProduct">
            <summary>
            Contains all things needed to read and create products from a uv style database.
            Currenlty Unused and Unfinished.
            </summary>
        </member>
        <member name="T:UV.Lib.Data.BarEventArgs">
            <summary>
            Thread Safety Notes:
            In order to better manage memory, this event will create the Bar objects 
            and manage these itself, reusing them when this object is reused.  The idea
            is that we maintain a (thread-safe) shared queue of BarEventArgs to be used 
            by MrData.CreateBar() and the DatabaseWriter thread.
            Usage:
            	Bar myBar = barEventArgs.GetBar();		// get a bar object
            	myBar.mySqlID = 200321;					// set values
            	myBar.bid = 20.02;						// etc....
            	barEventArgs.EnqueueBar(myBar);			// Give this back to the event arg
            </summary>
        </member>
        <member name="T:UV.Lib.Data.DataHub">
            <summary>
            Market Data Recorder 
            
            Currently this schedules itself to shutdown each day at 4:20.  This is due to
            TT and the lack of persistence across their server shutdowns.
            </summary>
        </member>
        <member name="M:UV.Lib.Data.DataHub.#ctor">
            <summary>
            Default Constructor called by the gui thread to start our data hub.
            </summary>
        </member>
        <member name="M:UV.Lib.Data.DataHub.RequestProductsToRecord(UV.Lib.Data.ProductRequest)">
            <summary>
            Threadsafe call to request products to recorded.  
            
            Warning this need to be improved to take into account illiquid months!
            </summary>
            <param name="productRequest"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Data.DataHub.TryCreateFromFile(System.String,UV.Lib.Data.DataHub@)">
            <returns>false if faled</returns>
        </member>
        <member name="M:UV.Lib.Data.DataHub.GetRequest(UV.Lib.Data.RequestCode)">
            <summary>
            This is helpful function to create/recycle request event args 
            for us internally.
            </summary>
        </member>
        <member name="M:UV.Lib.Data.DataHub.GetRequest(UV.Lib.Data.RequestCode,System.Object)">
            <summary>
            Overloaded version allows for data to be added.
            </summary>
        </member>
        <member name="M:UV.Lib.Data.DataHub.ProcessFoundResources(UV.Lib.MarketHubs.FoundServiceEventArg)">
            <summary>
            Called by the hub thread to deal with newly found resources from the market.  
            This is where we request subscription to price feeds we need.
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:UV.Lib.Data.DataHub.ProcessProductsToRecord(UV.Lib.Data.DataHubRequest)">
            <summary>
            Called by the hub thread to deal with requests for products to record. If more instruments are 
            requested at a later time this should handle it correctly, however this functionality is largely untested.
            </summary>
            <param name="requestArg"></param>
        </member>
        <member name="M:UV.Lib.Data.DataHub.ProcessMarketStatusChangedEvent(UV.Lib.MarketHubs.MarketStatusChangedEventArg)">
            <summary>
            Not Yet Implemented!
            </summary>
            <param name="eventArg"></param>
        </member>
        <member name="M:UV.Lib.Data.DataHub.CreateBar(System.DateTime)">
            <summary>
            This is called each time a bar must be created from a snapshot of the current market.
            New bars are pushed into the BarEventArg.BarList queue and handed to the QueryBuilder
            for query creation and writing.
            Called by internal hub thread.
            </summary>
        </member>
        <member name="M:UV.Lib.Data.DataHubRequest.Clear">
            <summary>
            Convenient way to clear object after recycling.
            </summary>
        </member>
        <member name="T:UV.Lib.Data.ProductRequest">
            <summary>
            Simple Object for Product Requests and a Method To Create them from a file
            </summary>
        </member>
        <member name="M:UV.Lib.Data.ProductRequest.#ctor(UV.Lib.Products.Product,System.Int32,System.Boolean)">
            <summary>
            Create a new product request object.
            </summary>
            <param name="product"></param>
            <param name="noOfInstrumentsToRecord"></param>
            <param name="isStandardInstrumentsOnly">Should we only consider products that have standard expirations and strucutres.  
            For ICE, if you want Cal and Q contracts, this should be set to false.</param>
        </member>
        <member name="M:UV.Lib.Data.ProductRequest.TryCreateFromFile(System.String,System.Collections.Generic.List{UV.Lib.Data.ProductRequest}@)">
            <summary>
            Attempt to create a product request from a file using Istringifiable interface.
            </summary>
            <param name="filePath"></param>
            <param name="prodRequestList"></param>
            <returns>false if faled</returns>
        </member>
        <member name="M:UV.Lib.Data.ProductRequest.Equals(UV.Lib.Data.ProductRequest)">
            <summary>
            iEquitable interface overide of Equals.  If both the product, and number of contracts to 
            request are equal, these objects are equal.
            </summary>
            <param name="prodRequest"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Data.ProductRequest.UV#Lib#IO#Xml#IStringifiable#GetAttributes">
            <summary>
            These are often called before everything is connected, so 
            you cant assume that there is a "StrategyHub" or Log here yet.
            </summary>
            <returns></returns>
        </member>
        <member name="P:UV.Lib.Data.ProductRequest.Product">
            <summary>
            Product that the request is for
            </summary>
        </member>
        <member name="P:UV.Lib.Data.ProductRequest.nInstrumentsToRecord">
            <summary>
            No of instruments from the front contract to request.
            </summary>
        </member>
        <member name="T:UV.Lib.Data.QueryBuilderHub">
            <summary>
            This is a helper class for the DataHub
            </summary>
        </member>
        <member name="M:UV.Lib.Data.QueryBuilderHub.RequestCheckInstrDBDetails(UV.Lib.Products.InstrumentDetails)">
            <summary>
            Called by external thread to request that the hub thread create a 
            query to check to make sure out database has the 
            instrument details supplied 
            correctly in the database.
            </summary>
            <param name="instrDetails"></param>
        </member>
        <member name="M:UV.Lib.Data.QueryBuilderHub.ProcessQueryBuildEvent">
            <summary>
            Creates the queury
            </summary>
        </member>
        <member name="M:UV.Lib.Data.QueryBuilderHub.ProcessRquestDBInstrDetails(UV.Lib.Data.QueryBuilderHubRequest)">
            <summary>
            called by the hub thread to process a request to create a query for instrument details
            </summary>
            <param name="requestArg"></param>
        </member>
        <member name="M:UV.Lib.Data.QueryBuilderHubRequest.Clear">
            <summary>
            Convenient way to clear object after recycling.
            </summary>
        </member>
        <member name="T:UV.Lib.Engines.Engine">
            <summary>
            This is the base class for all algorithmic components of a Strategy.
            Its wraps all parameters of the class, and creates parameter change messaging 
            for the object.
            Usage:
            1) Class that have parameters to expose to GUIs (herein called Engines)
                will extend this base class (or another Engine derivative, like PricingEngine).
            2) ParameterInfo objects will be created for each public property of class.
                ParameterInfo table created inside the "EngineInitialize" method.
                GUI Controls are also created.
            3) 
            Notes:
            1. Properties defined in this class are not displayed in the control panel.
                They are added to a list of properties to exclude.
            </summary>
        </member>
        <member name="T:UV.Lib.Engines.IEngine">
            <summary>
            
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.#ctor">
            <summary>
            This empty constructor provides support for Stringification.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.SetupInitialize(UV.Lib.Engines.IEngineHub,UV.Lib.Engines.IEngineContainer,System.Int32)">
            <summary>
            This is called immediately after construction, when we add this engine to its strategy.
            During this call the Parameter tables *must* be created, and all *Gui Templates* must be 
            created.
            If an Engine wants to create additional Engines, it should be done here.  Since *after*
            this initialize call (that is, during the SetupBegin() call), Engines can assume that all 
            other Engines have been created and added to the EngineList of the WStrategy.
            The short explanation:
                Setup Initialize:   Strategy, StrategyHub and other ApplicationServices exist.
                Setup Begin:        All Engines within my Strategy exist, and were SetupInitialize().
                Setup Complete:     All Engines in all Strategies exist and were SetUpBegin().
            Note: 
                1)  At this point, the Strategy has been created, but possibly no others.
                2)  The other engines in the Strategy may also not be created at this point.
                    * Therefore, Engines should not look for other Strategies of other Engines.
                3)  Subclasses should call this base-class method FIRST (so engineID is set) before other implementations.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.SetupInitialize(UV.Lib.Engines.IEngineHub,UV.Lib.Engines.IEngineContainer,System.Int32,System.Boolean)">
            <summary>
            This should be overridden if the user does NOT want the default Gui Template.
                1.) SetupGui = false will skip construction of the basic Engine Gui Template.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.SetupBegin(UV.Lib.Engines.IEngineHub,UV.Lib.Engines.IEngineContainer)">
            <summary>
            This is called after construction, as we are adding it to a strategy when Strategy is added to StrategyHub.
            Note: 
                1)  At this point, all Strategies have been created, along with their Engines, but each engine may 
                    be completely defined yet.
                2)  Subclasses should not try to make linkages between them yet.  Connections to other engines 
                    and strategies should be done during SetupComplete() call.
                3)  Subclasses should call this base-class method FIRST (so engineID is set).
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.SetupComplete">
            <summary>
            Call this after all Strategy Engines have had "SetupBegin()" is called.
            Note:
                1) 
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.SetupParameterInfoTable(UV.Lib.Engines.IEngineHub,UV.Lib.Engines.IEngineContainer)">
            <summary>
            Using reflection, this function loops thru all Parameter fields of inheriting super class
            at construction time and creates an array of ParameterInfo objects.
            Notes:
            int ii = 0;  // this with a invoke member call is what we need to abstractize the Engine class.
            try:  .InvokeMember("", System.Reflection.BindingFlags.GetProperty or SetProperty, null, o, new object[] { this });  
            props[0].InvokeMember("", System.Reflection.BindingFlags.GetProperty or SetProperty, null, o, new object[] { this });  
            System.Reflection.PropertyInfo propInfo = props[0];
            propInfo.CanRead; //propInfo.CanWrite; //propInfo.Name;//propInfo.DeclaringType;//propInfo.PropertyType;
            bool isW = (bool)propInfo.GetValue(this, null);
            propInfo.SetValue(this, isW, null);
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.SetupGuiTemplates">
            <summary>
            Creates a collection of templates to describe guis associated 
            with this particular engine.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.MarketInstrumentInitialized(UV.Lib.BookHubs.Book)">
            <summary>
            Called by the StrategyHub when our market instruments first become
            available.  If you extend the PricingEngine class, and override this
            method, call this base version first.
            </summary>
            <param name="marketBook"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Engines.Engine.ProcessEvent(System.EventArgs)">
            <summary>
            This method is the way that EngineEventArgs are passed to an engine to process.
            The action taken depends on the type of engine.  
            The implementation is required by IEngine; engines can override this implementation.  
            Current implementation:
             1. This implementation is most common, for a Strategy engine that receives from outsiders
             (normally user requests for parameter changes) to change its internal parameters.  
                A. It tries to make the requested changes and respond to the caller the results.
             2. If an engine overrides this with additional functionality, this method can still be 
             called to process all EngineEventArgs events, it does nothing and returns when passed
             any other type of event.
            </summary>
            <param name="e">Request passed in via an EngineEventArg.</param>
        </member>
        <member name="M:UV.Lib.Engines.Engine.AddSpontaneousEngineEvents(System.Collections.Generic.List{UV.Lib.Engines.EngineEventArgs})">
            <summary>
            The Engine class that inherits this base class, can spontaneously
            add messages based on its state changes etc, and periodically the 
            StrategyHub thread will call this, requesting that all events queued up
            in the EventQueue be added its "eventList" which is passed as an argument.
            Finally, the StrategyHub is responsible for sending these to EngineEvent subscribers.
            Notes:
                1. Overriding this method should call this base method first, which will 
                purge the queued events first.  New events might then be added to the StrategyHub
                eventList (rather than the just purged m_EventQueue).
            </summary>
            <param name="eventList"></param>
        </member>
        <member name="M:UV.Lib.Engines.Engine.GetGuiTemplates">
            <summary>
            New way to implement controls for Engines is via these
            Gui templates that define guis.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Engines.Engine.GetParameterValue(System.Boolean)">
            <summary>
            Returns a string-serialization of the Engine parameters for saving.
            </summary>
            <param name="ignoreReadOnlyFields">true will not return read-only parameters.</param>
            <returns>a string of parameter name, value pairs.</returns>
        </member>
        <member name="M:UV.Lib.Engines.Engine.GetEventForParameterValues(UV.Lib.Engines.IEngineContainer)">
            <summary>
            This method allows an outsider to ask the Engine to automatically create 
            the appropriate EngineEventArg that can be used to have it broadcast its 
            current parameter values. 
            This is useful when the Engine's parameters have been changed internally 
            by some method, orther than the usual EngineEventArg parameter Change request, 
            which will usually produce a response event automatically anyway.
            For example, use this when an engine parameter spontaneously changes (from
            a market event, or fill, or by the action of a model) to send the new parameter
            values to all GUIs, even though no one requested one.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.Engine.BroadcastAllParameters(UV.Lib.Engines.IEngineHub,UV.Lib.Engines.IEngineContainer)">
            <summary>
            This method allows an engine to broadcast all of his own parameters even if not
            requested by the user.  This is useful when the engine changed its parameters automatically, 
            and now wants to ensure the user knows about it.
            </summary>
            <param name="hub"></param>
            <param name="parent"></param>
        </member>
        <member name="M:UV.Lib.Engines.Engine.BroadcastParameter(UV.Lib.Engines.IEngineHub,UV.Lib.Engines.IEngineContainer,System.Int32)">
            <summary>
            This methods allows an engine to broadcast a single parameter that has not been requested by the user
            If a parameter is changed internally (programatically) this can be used to transmit to the gui.
            </summary>
            <param name="hub"></param>
            <param name="parent"></param>
            <param name="propertyId"></param>
        </member>
        <member name="M:UV.Lib.Engines.Engine.GetParameterId(System.String)">
            <summary>
            
            </summary>
            <param name="parameterName"></param>
            <returns>PropertyId value, else -1 if no property has provided name.</returns>
        </member>
        <member name="M:UV.Lib.Engines.Engine.GetParameterValue(System.Int32[]@,System.Collections.Generic.List{System.Object}@)">
            <summary>
            Given an array of parameterIDs and a list, the current values of the parameters
            are loaded into the list.  IF!! the array parameterID[] is empty or a null, then
            all parameterIDs and their values are returned.
            </summary>
            <param name="parameterID"></param>
            <param name="valueList"></param>
            <returns>true if successfully found parameter values.</returns>
        </member>
        <member name="P:UV.Lib.Engines.Engine.IsUpdateRequired">
            <summary>
            Override this IF the inheriting class has a non-trivial test to perform
            to ensure its ready to run.  Otherwise, this returns the trivial "Ready"
            response.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.EngineEventArgs.RequestAllParameters(System.String,System.Int32,System.Int32)">
            <summary>
            Requests all parameter values from one engine.
            </summary>
        </member>
        <member name="M:UV.Lib.Engines.EngineEventArgs.RequestAllParameters(System.String,UV.Lib.Engines.IEngineContainer)">
            <summary>
            This is a convenient overload for the Guis.  They will have a container that 
            is one-to-one with the engines they are interested in getting parameters for.
            </summary>
            <param name="engineHubName">StrategyHub of engines with desired parameters</param>
            <param name="container">a container that has engineId's that match those you are interested in.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Engines.IEngineContainer.ProcessEvent(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns>true if any of its engines IsUpdateRequired = true.</returns>
        </member>
        <member name="T:UV.Lib.Engines.IPricingEngine">
            <summary>
            This exposes the functionality that a Strategy object must 
            call in order for it to re-price itself.
            Notes:
            1. This interface is in the engine library so that Engine.cs base class
            knows of its existance, and the exposed properties of this interface will 
            be ignored by the automatic control creation.
            </summary>
        </member>
        <member name="T:UV.Lib.Engines.ParameterInfo">
            <summary>
            Each of these objects contains information for formatting and displaying
            the engine's parameters.
            Note: A copy of these might be loading into controls so formatting and
            purposes.
            TODO: 1.  Ultimately make this a read-only object!
            </summary>
        </member>
        <member name="M:UV.Lib.Excel.RTD.TopicBase.SetValue(System.String)">
            <summary>
            This is the data that will be reported Excel on the next update.
            When this property is set, the topic is flagged as having changed; when the value is 
            read, the topic is IsValueChanged flagged is set to false. (We assume there is only 
            one read event when the value is loaded into the Excel array.)
            Threading: This locks the data when setting/getting.
            </summary>
        </member>
        <member name="M:UV.Lib.Excel.RTD.TopicBase.SerializeCurrent(UV.Lib.Excel.RTD.MessageType)">
            <summary>
            Only serializes the id and the Current Value.
            </summary>
        </member>
        <member name="M:UV.Lib.Excel.RTD.TopicBase.Serialize">
            <summary>
            Serializes the entire object.
            </summary>
        </member>
        <member name="M:UV.Lib.Fills.Fill.Clone">
            <summary>
            Shallow clone method for fill object
            </summary>
            <returns>shallowly cloned Fill Object</returns>
        </member>
        <member name="M:UV.Lib.Fills.FillBook.#ctor(System.String,System.Double)">
            <summary>
            Construct a new fillbook for a given instrument.
            </summary>
            <param name="instrument">name of security</param>
            <param name="contractMultiplier">contractMultiplier of instrument.  This should be the dollar value of an integerized price changed for the instrument</param>
        </member>
        <member name="M:UV.Lib.Fills.FillBook.TryAdd(UV.Lib.Fills.Fill)">
            <summary>
            Add new Fill to the fill book
            </summary>
            <param name="aFill"></param>
            <returns>false if add failed</returns>
        </member>
        <member name="M:UV.Lib.Fills.FillBook.ResetRealizedDollarGains">
            <summary>
            Allows user to reset the PnL.  Useful at the end of a trading session, 
            if we don't want to roll our PnL forward into the next session.
            </summary>
        </member>
        <member name="M:UV.Lib.Fills.FillBook.ResetRealizedDollarGains(System.Double,System.Double)">
            <summary>
            Allows the user to set the current gains for this book.  If only one of them needs to be set, 
            then the user can pass a NaN for the other (which will be skipped).
            </summary>
            <param name="todaysRealPnL">PnL (in book's currency) realized since last reset time.</param>
            <param name="openingRealPnL">PnL (in book's currency) realized over lifetime.</param>
        </member>
        <member name="M:UV.Lib.Fills.FillBook.RecalculateAll">
            <summary>
            The user can demand that all internal values are recaulated.  Useful upon initialization.
            </summary>
        </member>
        <member name="M:UV.Lib.Fills.FillBook.UpdatePositionInfo">
            <summary>
            Update Net Positions and Average Costs
            </summary>
        </member>
        <member name="M:UV.Lib.Fills.FillPage.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="sideOfOrders">Each FillPage contains Long or Short Fills</param>
        </member>
        <member name="M:UV.Lib.Fills.FillPage.TryAdd(UV.Lib.Fills.Fill)">
            <summary>
            TryAdd will attempt to add a fill to both the synthetic Queue of 
            fills as well as the historic list of fills return a bool for
            the status of acceptance into these collections.
            </summary>
            <param name="newFill"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Fills.FillPage.GetPendingQty">
            <summary>
            Finds total pending or unassigned(to a synthetic) fill Qty. NOTE: this is NOT and abs value.
            </summary>
            <returns>long fill qty that is currently unnassgined/pending</returns>
        </member>
        <member name="M:UV.Lib.Fills.FillPage.DequeueQty(System.Int32,System.Collections.Generic.List{UV.Lib.Fills.Fill}@)">
            <summary>
            Decrements a list of fills based on Qty needed, always pulling 
            unnassigned fill Qty's from the top.  If the user wants the specific
            fills that are dequeued they will be outputed in referenced fillsDequeued.
                Note : These fills will have qty manipulated if that have been split!
            </summary>
            <param name="qtyToRemove"></param>
            <param name="fillsDequeued"></param>
            <returns>false if remove failed</returns>
        </member>
        <member name="M:UV.Lib.Fills.FillPage.GetAveragePricing(System.Int64)">
            <summary>
            Find the average price of the given qty of fills from the top of the list of 
            pending fills
            </summary>
            <param name="qty"></param>
            <returns>double of average price</returns>
        </member>
        <member name="M:UV.Lib.Fills.SyntheticFill.CreateSyntheticFillFromFill(UV.Lib.Fills.Fill)">
            <summary>
            Callers has a Fill that they would like to convert to a Synthetic Fill
            to be allow it to be passed to a strategy.
            </summary>
            <param name="fill"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.FrontEnds.Graphs.ZGraphText">
            <summary>
            This is a template for classes.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.GuiTemplates.EngineContainerGui">
            <summary>
            
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.BoxNumeric.#ctor(System.Double,System.Int32,UV.Lib.FrontEnds.Clusters.ColorPalette)">
            <summary>
            The main overload for constructing this box.
            </summary>
            <param name="minTickSize"></param>
            <param name="userDefinedBoxID">User-defined ID number that can be used to identify 
            	this box to its owner.  This is useful when it responds to user-click events, 
            	so the owner (a Row object) can uniquely identify this particular box. </param>
            <param name="colorPreference"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.BoxNumeric.RegisterMouseEvents(UV.Lib.FrontEnds.Clusters.Cluster,System.Int32)">
            <summary>
            Register the provided Cluster to receive specific Mouse Events from this box.
            </summary>
            <param name="aCluster"></param>
            <param name="rowID"></param>
        </member>
        <member name="P:UV.Lib.FrontEnds.Clusters.BoxNumeric.TickValue">
            <summary>
            This is the most important property of this control.  It is the 
            only way in which new values are accepted to be displayed by this control.
            This method updates the displayed value, and MUST be called by the window thread.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.Clusters.ColorPalette">
            <summary>
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.BoxRow.UpdateHiLite(System.Int32[])">
            <summary>
            Allows the application to apply HiLite colors to the forground.
            </summary>
            <param name="hiLiteCodes">Array of m_Box.Length that gives the "hi-lite value"
            	parameter.  A value of "0" = default, not hi-lited.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.BoxRow.RegisterMouseEvents(UV.Lib.FrontEnds.Clusters.Cluster,System.Int32)">
            <summary>
            This registers sets all my boxes to register mouse events with my parent
            cluster.
            </summary>
            <param name="aCluster">Parent cluster</param>
            <param name="rowID"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.InitializeBoxRowControl(UV.Lib.FrontEnds.GuiTemplates.EngineContainerGui)">
            <summary>
            Initializes the BoxRowControl object, which right now is hard-coding inside
            this object.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.InitializeLayout">
            <summary>
            Places and paints all the controls in the Cluster.  
            This also creates the BoxRows.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.RegisterMouseEvents">
            <summary>
            Tells each (or any) BoxRow objects to send mouse-click events they receive
            to this Cluster, which in turn sends them to the StrategyHub associated 
            with this Cluster.  
            The BoxRow will call "BoxNumeric_Click()" event handler.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.AcceptNewParentDisplay(UV.Lib.FrontEnds.Clusters.ClusterDisplay)">
            <summary>
            Clusters are typically created by the strategies (EngineContainers) that
            they are meant to display information about.  However, the object that actually 
            does the work of updating/repainting them may be a different object entirely, like
            a "display hub".
            The creating strategy hub passes the cluster to the display hub, and the display hub 
            calls this method to tell the cluster it now has a new owner.
            </summary>
            <param name="display"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.RegenerateNow">
            <summary>
            If any regeneration is needed, we loop thru each boxRow, checking whether
            that row in particular needs regenerating, if so we call its updateValue() method.
            By "regenerating", I mean that the memory value has been changed by the hub, but
            the displayed value needs updating by the windows thread.
            Note: This method must be called by the windows thread!
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.RegenerateMemory(System.Double[],System.Double[],System.Int32[],System.Int32[],System.Double[])">
            <summary>
            Given a market depth from an "MarketChange" Engine Event, we recreate the market
            here.
            If something has changed, we set IsRegenRequired = true, so the windows thread
            can be invoked to repaint the controls.
            TODO: This needs major efficiency improvements.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.RegenerateMemory(UV.Lib.Engines.EngineEventArgs)">
            <summary>
            Main entry point for Cluster events. 
            Cluster events can come from any engine.  But when it comes from the pricing engine
            it could shift the entire cluster.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.RegenerateBoxRow(System.Int32)">
            <summary>
            Updates the BoxRow.
            </summary>
            <param name="rowID">RowID of BoxRow to update.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.BoxNumeric_Click(System.Object,System.EventArgs)">
            <summary>
            The event handler for whenever the user Clicks on a Box that is 
            owned by this Cluster.  
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.BoxNumeric_MouseEnter(System.Object,System.EventArgs)">
            <summary>
            For some BoxRow objects, the Cluster wants to know when they are moused-over.
            For example, when the mouse is over a BoxRow, we will not shift the prices, so that
            the user doesn't have price levels shifting beneath his mouse as he is clicking somewhere.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.ProcessEvent(System.EventArgs)">
            <summary>
            Implements IEngineContainer.  This is called by my hub thread when it receives an 
            EngineEvent.  The engine event will be passed to the correct engines.
            </summary>
            <param name="eventArgs"></param>
        </member>
        <member name="F:UV.Lib.FrontEnds.Clusters.Cluster.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Cluster.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterConfiguration.Clone">
            <summary>
            Using serialization techniques, this method creates a new clone
            of this object.
            </summary>
            <returns>A new object that is a copy of this one.</returns>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.#ctor(UV.Lib.Hubs.Hub,UV.Lib.Engines.IEngineHub,System.Collections.Generic.List{UV.Lib.FrontEnds.GuiTemplates.EngineContainerGui})">
            <summary>
            Note: 
            1) Since this method is called from the GuiCreator, any changes to its signature 
            must be implemented in the GuiCreator call as well!
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.RegenerateLayout">
            <summary>
            Retile and update the cluster layout.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.RegenerateNow(System.Object,System.EventArgs)">
            <summary>
            Immediately update the visual components of the Clusters.
            Loops through each cluster in my list, calling their "RegenerateNow()" methods, 
            which will update their displays.
            Threads: When called by non-GUI thread, then an invoke is made for GUI thread.
            </summary>
            <param name="sender"></param>
            <param name="eArgs"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.HubEventEnqueue(System.EventArgs)">
            <summary>
            ClusterDisplay events are passed here by the FrontEndServer thread.
            The calling thread can update the internal values of clusters, and popups, 
            but cannont directly update the Controls themselves.
            </summary>
            <param name="eventArgs"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.MenuItem_CLick(System.Object,System.EventArgs)">
            <summary>
            This event handles all Menu Item selections by user.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.GraphDisplay_FormClosed(System.Object,System.Windows.Forms.FormClosedEventArgs)">
            <summary>
            Event handler for user closing out the graph window.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:UV.Lib.FrontEnds.Clusters.ClusterDisplay.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.ClusterDisplay.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.Clusters.ClusterEventArgs.BoxRowType">
            <summary>
            This enum tells the Strategy that receives this event what type of "row" 
            in the associated cluster was clicked on.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Header.#ctor(UV.Lib.Engines.IEngineContainer,UV.Lib.FrontEnds.GuiTemplates.EngineContainerGui)">
            <summary>
            Constructor for the Header in a Cluster object.   This is called from 
            a Cluster constructor and therefore by a GUI thread.  
            The Cluster constructor is called using reflection but uses an invoke on the
            GUI thread. 
            </summary>
            <param name="parent"></param>
            <param name="container">The container (think Strategy) associated with this Cluster.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Header.ProcessEngineEvent(UV.Lib.Engines.EngineEventArgs)">
            <summary>
            Called from cluster to process engine events it received from StrategyHub.
            </summary>
            <param name="eArgs"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Header.CloseAllPopUps(UV.Lib.FrontEnds.PopUps.IPopUp)">
            <summary>
            This creates and places a small click-able label used as a menu entry
            to have access to a paritcular engine parameter control panel.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Header.comboBoxEngines_SelectionChangeCommitted(System.Object,System.EventArgs)">
            <summary>
            The user has selected a specific engine name from the dropdown list.
            Find the Popup associated with this engine name, and show it.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Clusters.Header.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Header.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Clusters.Header.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.Graphs.GraphHolder">
            <summary>
            This is a form that holds multiple PopUp forms, allowing them
            to be easily tiled and controlled collectively.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.GraphHolder.LocateTopMostForm(System.Collections.Generic.List{System.Windows.Forms.Form})">
            <summary>
            Returns the form that is most closest to the upper-left corner.
            </summary>
            <param name="formList">List of forms to compare</param>
            <returns>form closest to upper left corner</returns>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.GraphHolder.GetOrderedChildren(System.Collections.Generic.List{System.Windows.Forms.Form})">
            <summary>
            Returns a list of forms ordered according to their approximate locations.
            The algorithm divides the area into horizontal strips, and orders the 
            forms from left to right, then top to bottom.
            </summary>
            <param name="allChildren">list of forms to compare</param>
            <returns>list of same forms, ordered.</returns>
        </member>
        <member name="F:UV.Lib.FrontEnds.Graphs.GraphHolder.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.GraphHolder.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.GraphHolder.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.PopUps.IEngineControl">
            <summary>
            This represents a control that fills a popup form on which 
            various controls are contained for a particular engine.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ShowMe(System.Windows.Forms.Form)">
            <summary>
            Currently, this is necessary to resolve two issues.
            First, the zed graph control, zg1 below, must be created by this windows
            thread that will repaint it.
            Secondly, I want a zed graph to have different form-border properties than
            other pop-up forms.  On being openned for the first time, this method will 
            change the properties of its parent form.
            </summary>
            <param name="parentControl"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ConstructZedGraphControl(ZedGraph.ZedGraphControl)">
            <summary>
            This is called by the windows thread that will display this
            control.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.InitializeZedGraphControl(ZedGraph.ZedGraphControl)">
            <summary>
            After the zed graph is created, we can initialize its look here.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ZedGraph_Resize(System.Object,System.EventArgs)">
            <summary>
            On resize action, resize the ZedGraphControl to fill most of the Form, with a small
            margin around the outside
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ZedGraph_PointValueHandler(ZedGraph.ZedGraphControl,ZedGraph.GraphPane,ZedGraph.CurveItem,System.Int32)">
            <summary>
            Display customized tooltips when the mouse hovers over a point
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ZedGraph_ContextMenuBuilder(ZedGraph.ZedGraphControl,System.Windows.Forms.ContextMenuStrip,System.Drawing.Point,ZedGraph.ZedGraphControl.ContextMenuObjectState)">
            <summary>
            Customize the context menu by adding a new item to the end of the menu
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ShowGraph(System.Object,System.EventArgs)">
            <summary>
            The user has selected a new graph to show from the context menu.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.ZedGraph_ZoomEvent(ZedGraph.ZedGraphControl,ZedGraph.ZoomState,ZedGraph.ZoomState)">
            <summary>
            Respond to a Zoom Event.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Graphs.ZGraphControl.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Graphs.ZGraphControl.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.FrontEndServer">
            <summary>
            This is a service that can subscribe to and display GUIs for IEngineHubs.
            Features:
                1) When we are shutting down, take care to shutdown each display gently.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.AddEngineHub(System.String)">
            <summary>
            Submit a request to connect to a specific EngineHub.
            Currently, only one engineHub is serviced - but this may change.
            Called by external thread.
            </summary>
            <param name="engineHub">EngineHub to be monitored.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.TryRequestDisplay(System.String)">
            <summary>
            User request creation of new display.  The request 
            generates a call to get the GuiTemplates, and then 
            automatically opens the form when completed.
            TODO:
                1) Allow user to choose which hub to create display for.
                2) Allow user to choose which Clusters are added, etc.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.HubEventHandler(System.EventArgs[])">
            <summary>
            Main request handling routine processing all events originating from 
            external and internal sources.
            Called only by the internal hub thread.
            </summary>
            <param name="eventArgList">Array of EventArgs to be processed.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.ProcessEngineEvents(UV.Lib.Engines.EngineEventArgs)">
            <summary>
            These are events broadcast from Engines on the StrategyHub (typically).
            Confirmation of parameter changes must be passed to the guis that 
            represent them.
            </summary>
            <param name="engineEvent"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.ProcessFrontEndRequest(UV.Lib.FrontEnds.FrontEndServer.FrontEndRequest)">
            <summary>
            These are my internal requests, used to create new GUI displays, etc.
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.ProcessCreatedForm(UV.Lib.FrontEnds.Utilities.GuiCreator.CreateFormEventArgs)">
            <summary>
            A new Form has been created by the GUI thread, and is now ready to 
            be employed.  We request all controls for this display (based on the type 
            of display it is).
            </summary>
            <param name="anEventArg"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.ClusterDisplay_FormClosing(System.Object,System.Windows.Forms.FormClosingEventArgs)">
            <summary>
            Called when the user closes a Display.  I will request it to be 
            removed from my list.
            Called by an external thread.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.FrontEndServer.EngineHub_ServiceStateChanged(System.Object,System.EventArgs)">
            <summary>
            Call back from EngineHubs that we are displaying.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.FrontEndServices">
            <summary>
            This is DEFUNCT.  Replaced by AppInfo class.
            Receptical for important constants, directory locations etc.
            </summary>
        </member>
        <member name="P:UV.Lib.FrontEnds.FrontEndServices.IsCurrentRunProduction">
            <summary>
            Returns true, if current RunName is one of the production choices?
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.FrontEndServices.RunNameType">
            <summary>
            Note: 
            1) All types that are "production run" types MUST start with letters "Prod".
            2) These must be preset as prefixes of Tango strategies, if using Tango.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Huds.HudPanel.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Huds.HudPanel.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Huds.HudPanel.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:UV.Lib.FrontEnds.Huds.HudPanel.SmallestSize">
            <summary>
            Returns smallest size needed to display its controls.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Huds.MultiPanel.ProcessEngineEvent(UV.Lib.Engines.EngineEventArgs)">
            <summary>
            Called from cluster to process engine events.
            </summary>
            <param name="eArgs"></param>
        </member>
        <member name="F:UV.Lib.FrontEnds.Huds.MultiPanel.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Huds.MultiPanel.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Huds.MultiPanel.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.PopUps.EngineControl">
            <summary>
            This class represents a control panel displayed inside the PopUp1 form.
            This object holds a list of "parameter controls", one for each engine parameter.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.EngineControl.InitializeLayout">
            <summary>
            Now its time to create the controls.
            Note:
                Must be called by the UI thread.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.EngineControl.CreateObjectControl(UV.Lib.Engines.ParameterInfo)">
            <summary>
            If the parameter info type is an object, we search for known object types
            and create the appropriate control here. Otherwise, we ignore it.
            </summary>
            <param name="pInfo"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.EngineControl.TitleBar_Click(System.Object,System.EventArgs)">
            <summary>
            Allows user to close the popup by clicking anywhere inside the visible area.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.EngineControl.SetupComplete">
            <summary>
            Implementation for IEngine
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.EngineControl.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.EngineControl.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.EngineControl.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:UV.Lib.FrontEnds.PopUps.EngineControl.IsUpdateRequired">
            <summary>
            Implements IEngine.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.PopUps.ParamControlBase">
            <summary>
            This is the base class for a control that displays a single parameter.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamControlBase.SetValue(System.Object)">
            <summary>
            This overwrites the value of the parameter that is stored in Memory.
            But does not update the on screen value.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamControlBase.Regenerate">
            <summary>
            This must be called by windows thread only!  
            Call this method when you want to update the displayed value to make it
            reflect the stored value in Memory.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamControlBase.InitializeParameter(UV.Lib.Engines.ParameterInfo)">
            <summary>
            This must be called by windows thread only!
            Call this method in the constructor when the method is first created.
            Also, HUD creation sometimes calls this method too.  
            </summary>
            <param name="parameterInfo"></param>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamControlBase.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamControlBase.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamBool2.SetValue(System.Object)">
            <summary>
            Implements ParamControlBase.
            This method updates the internal memory of this control, and so
            can be called by any thread.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamBool2.Regenerate">
            <summary>
            This method replaces the displayed quantity with that stored in memory.
            This must be called by windows thread only!
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamBool2.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamBool2.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamBool2.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamDouble2.Regenerate">
            <summary>
            Copies the value of the parameter from internal memory to the text box.
            This must be called by windows thread only!
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamDouble2.textBox_KeyUp(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
            Handles when a user types into the textbox.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamDouble2.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamDouble2.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamDouble2.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamEnum.SetValue(System.Object)">
            <summary>
            Implements ParamControlBase.
            This method updates the internal memory of this control, and so
            can be called by any thread.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamEnum.Regenerate">
            <summary>
            This method replaces the displayed quantity with that stored in memory.
            This must be called by windows thread only!
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamEnum.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamEnum.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamEnum.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamInteger2.Regenerate">
            <summary>
            Copies the value of the parameter from internal memory to the text box.
            This must be called by windows thread only!
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamInteger2.textBox_KeyUp(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
            Handles when a user types into the textbox.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamInteger2.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamInteger2.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamInteger2.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamString.Regenerate">
            <summary>
            Copies the value of the parameter from internal memory to the text box.
            This must be called by windows thread only!
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamString.textBox_KeyUp(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
            Handles when a user types into the textbox.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamString.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamString.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamString.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.PopUps.ParamUnknown">
            <summary>
            This is a blank place holder for engine parameters of unknown type.
            Only the name of the parameter is listed.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.ParamUnknown.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamUnknown.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.ParamUnknown.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.PopUps.PopUp1">
            <summary>
            Form that holds a single IEngineControl object for displaying.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.PopUp1.ShowMe(System.Windows.Forms.Control)">
            <summary>
            Show the control.  Implements IPopUp.
            Called by the GUI thread.
            </summary>
            <param name="spawnControl">Control onto which popup is painted.</param>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.PopUp1.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.PopUp1.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.PopUp1.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.PopUps.PopUp2">
            <summary>
            This version of an IPopUp form is not in use now.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.PopUp2.ShowMe(System.Windows.Forms.Control)">
            <summary>
            Show the control.  Implements IPopUp.
            </summary>
            <param name="spawnControl">Control onto which popup is painted.</param>
        </member>
        <member name="F:UV.Lib.FrontEnds.PopUps.PopUp2.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.PopUp2.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.PopUps.PopUp2.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:UV.Lib.FrontEnds.PopUps.PopUp2.CustomControl">
            <summary>
            Implements IPopUp.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.ControlTools.SetCheck(System.Windows.Forms.Control,System.Windows.Forms.ToolStripMenuItem,System.Boolean)">
            <summary>
            Allows called to asynchronously check a control.
            </summary>
            <param name="parentForm"></param>
            <param name="menuItem"></param>
            <param name="isCheck">Whether to set/reset check mark.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.ControlTools.SetText(System.Windows.Forms.Control,System.String)">
            <summary>
            Caller can set Text property of control asynchronously.
            </summary>
            <param name="control"></param>
            <param name="text"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.ControlTools.TrySwapBGColor(System.Windows.Forms.Control,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Used for making the BG Color of a control flash.  If control.BackColor equals
            either of the two colors provided, then it will toggle it to the other color.
            TODO: Generalize this to an array of colors?
            </summary>
            <param name="control"></param>
            <param name="color1"></param>
            <param name="color2"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.ControlTools.SetBalloonTip(System.Windows.Forms.Form,System.Windows.Forms.NotifyIcon,System.String,System.Int32)">
            <summary>
            </summary>
            <param name="parentForm"></param>
            <param name="control"></param>
            <param name="message"></param>
            <param name="tipShowDuration"></param>
        </member>
        <member name="T:UV.Lib.FrontEnds.Utilities.GuiCreator">
            <summary>
            Used to create GUIs from threads other than the UI thread.  
            Usage: 
                1) Create an instance of the UI Dispatched by calling Create() with NO args on the UI thread!
                2) From then on, anyone can create a new instance by calling Create( formType, args[]), 
                    Step 1:     Create a new instance of the GuiCreator for that user, but this instance
                                already has a pointer to the correct UI Dispatcher.
                    Step 2:     Then, subscribe to the event in this private GuiCreator object.
                    Step 3:     Then, call its "Start()" method.
                3) When the event is triggered, the created form will be inside.
            TODO:
                1) We need to manage removing delegates after final call.  MAke reusable ?
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.GuiCreator.TryCreateControl(System.Windows.Forms.Control@,System.Type,System.Object[])">
            <summary>
            Static function to aid in Control creation.
            Must be called by the UI thread.
            </summary>
            <param name="newControl"></param>
            <param name="t"></param>
            <param name="constructorArgs"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.GuiCreator.CreateForm(System.Object,System.EventArgs)">
            <summary>
            This is the method called using the Dispatcher of the UI thread.
            </summary>
            <param name="obj"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.GuiCreator.ShowMessageBox(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon)">
            <summary>
            A simple asynchronous way to open a Message box.  The caller is
            immediately released, and internally a flag is set to allow only one
            message box at a time.
            </summary>
            <param name="msgText">Possibly multiple line of text for body of message.</param>
            <param name="captionText">Title of popup form.</param>
            <param name="buttons">Buttons to show.</param>
            <param name="icon">Icon image to show in box.</param>
            <returns></returns>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.PropertyForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.PropertyForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.PropertyForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.Utilities.SystemMenuManager">
            <summary>
            Removes and disables the Move and Close items in a form's system menu.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.SC_MOVE">
            <summary>
            Represents the Move menu item.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.SC_CLOSE">
            <summary>
            Represents the Close menu item.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MF_BYCOMMAND">
            <summary>
            Indicates that a menu item is identified by command ID.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MF_ENABLED">
            <summary>
            Indicates that a menu item is enabled.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MF_GRAYED">
            <summary>
            Indicates that a menu item is greyed out.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MF_DISABLED">
            <summary>
            Indicates that a menu item is disabled.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.target">
            <summary>
            The form whose menu is being managed.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.closeState">
            <summary>
            The state of the form's Close menu item.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.menuHandle">
            <summary>
            The handle of the menu being managed.
            </summary>
        </member>
        <member name="M:UV.Lib.FrontEnds.Utilities.SystemMenuManager.RefreshCloseItem">
            <summary>
            Sets the state of the Close menu item if present but not enabled.
            </summary>
        </member>
        <member name="T:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MenuItemState">
            <summary>
            The possible states of a menu item.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MenuItemState.Enabled">
            <summary>
            Appears normal and responds to clicks.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MenuItemState.Greyed">
            <summary>
            Appears greyed out and does not respond to clicks.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MenuItemState.Disabled">
            <summary>
            Appears normal but does not respond to clicks.
            </summary>
        </member>
        <member name="F:UV.Lib.FrontEnds.Utilities.SystemMenuManager.MenuItemState.Removed">
            <summary>
            Is not present.
            </summary>
        </member>
        <member name="T:UV.Lib.Hubs.LogHub">
            <summary>
            An external thread passes a string (and other info) by calling one of the 
            public methods NewEntry(), BeginEntry(), AppendEntry(), etc which loads the
            message into a LogEventArg object.
            This is pushed onto the local HubBase event queue, via the usual HubEventEnqueue(). 
            for later processing and subsequent pushing onto an outgoing message queue.
            Thereafter, the HubBase thread awakens and passes the eventArg back up to 
            LogHub.HubEventHandler( EventArg ) which unpacks the string message, and processes it.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.#ctor(System.String,System.String,System.Boolean,UV.Lib.Hubs.LogLevel)">
            <summary>
            Main constructor.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.Initialize">
            <summary>
            Called by main GUI Thread via a constructor.  Allows creation of form, if desired.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.NewEntry(UV.Lib.Hubs.LogLevel,System.String,System.Object[])">
            <summary>
            The most basic way to create a single, new log entry.
            </summary>
            <param name="msgLevel"></param>
            <param name="formatString"></param>
            <param name="args"></param>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.BeginEntry(UV.Lib.Hubs.LogLevel)">
            <summary>
            This method is called when the user wants to create a compound message in the Log.
            First this method is called, followed by AppendEntry() repeatedly, and then EndEntry()
            completes the message and submits it.
            This is thread safe since each caller thread has its own working message space.
            </summary>
            <param name="msgType"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.InsertEntry(System.String,System.Object[])">
            <summary>
            This method inserts a string at front of the working message.
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.EndEntry(System.Boolean)">
            <summary>
            This is called after BeingEntry() and possibly multiple AppendEntry() methods
            have been called to finalize the compound message and finally push onto thread queue
            for processing.
            </summary>
            <param name="acceptEntry"></param>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.GetEntry">
            <summary>
            Allows user to get a copy of full msg being constructed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.Stop">
            <summary>
            This method is called by an external thread.
            Since all file handling is done asynchronously, we have to request a stop
            to the Log keeping service.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.RemoveLogViewer(UV.Lib.Hubs.LogViewer)">
            <summary>
            TODO: This does not seem to be thread-safe!!  Can't we be writing to LogViewer after
            user has closed and destroyed object?
            </summary>
            <param name="viewerToRemove"></param>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.CreateOutputFileName">
            <summary>
            Creates a unique output file name based on the hub name, the startup time, 
            and makes sure its unique.
            Called by the local hub thread.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.TryOpenOutputFile(System.IO.StreamWriter@)">
            <summary>
            Opens an output log file, named in m_OutputFileName.  
            This method should make multiple attempts to open the output file before giving up.
            Called by local thread.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.FlushOutQueue">
            <summary>
            This private method is called by the HubThread whenever we want to 
            write the current contents of the out buffer to the out file.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.ProcessStopRequest">
            <summary>
            Called by the LogHub thread when a request to shut down the log
            has been received.  This method will do a friendly shut down.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.BuildMessage(UV.Lib.Hubs.LogHub.LogEventArgs)">
            <summary>
            In new approach, the LogEventArg contains a timespan computed 
            using the StopWatch when the event was created - since thats the time the
            event was triggered.
            This is called by the internal hub thread.  As such, it is completely threadsafe.
            </summary>
            <param name="e"></param>
            <returns>Completed message </returns>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.GetNewLogEvent(UV.Lib.Hubs.LogHub.LogRequest,System.String,UV.Lib.Hubs.LogLevel,System.TimeSpan)">
            <summary>
            When the outside thread wants to make a request, he calls this method which 
            rather than creating  new event, simply takes the next one from off a stack of event args. 
            The hub thread returns used eventArgs back to the stack after ProcessOutMessage().
            </summary>
            <param name="req"></param>
            <param name="message"></param>
            <param name="level"></param>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.CreateLogViewer">
            <summary>
            
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogHub.HubEventHandler(System.EventArgs[])">
            <summary>
            This method is called by the LogHub thread to process a new log message 
            or a special log request (such as "flush buffers" etc).
            </summary>
            <param name="eventArgArray"></param>
        </member>
        <member name="T:UV.Lib.Hubs.LogLevel">
            <summary>
            This enum provides information regarding the types of log 
            entries.
            </summary>
        </member>
        <member name="T:UV.Lib.Hubs.LogViewCreator">
            <summary>
            DEFUNCT:  This has been replaced by UV.FrontEnds.Utilites.GuiCreator
            
            This method is a helper class for LogViewer.  A single instance of it
            is created when the LogHub is created (by the GUI thread).
            From then on, a LogHub can call CreateInvoke() to create new LogViewer forms 
            from a non-GUI thread!
            TODO:  This can be generalized!
            1. Allow features of the LogViewer to be determined by the caller.
            2. Generalize this to a Form factory service that once created can create
            asynchronously ANY 
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewCreator.#ctor">
            <summary>
            This object must be created by the GUI thread.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewCreator.CreateInvoke(System.Object,System.String)">
            <summary>
            Called by non-gui thread to create a LogViewer.
            </summary>
            <param name="o"></param>
            <param name="msg"></param>
        </member>
        <member name="F:UV.Lib.Hubs.LogViewCreator.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewCreator.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewCreator.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewer.AddMessage(System.String)">
            <summary>
            Called by external thread to add a new message to be displayed.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewer.LogUpdate(System.Object,System.EventArgs)">
            <summary>
            Called by external or GUI thread.  This forces the logviewer to update itself
            and reflect the loghub.  
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewer.LogClose(System.Object,System.EventArgs)">
            <summary>
            Called by external or GUI thread.  This forces the logviewer to update itself
            and reflect the loghub.  
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="F:UV.Lib.Hubs.LogViewer.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewer.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:UV.Lib.Hubs.LogViewer.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:UV.Lib.IO.BackwardReader">
            <summary>
            http://codepaste.net/nkb9hp  by Ken Wiebke
            </summary>
        </member>
        <member name="T:UV.Lib.IO.Drops.DropQueueWriter">
            <summary>
            The simplest queued line-writer .  It could be used for logs, or drop copies.
            It has no log of its own, optionally, a LogHub can be handed to it at construction.
            It has a concurrent queue, to events (with messages to write, perhaps) can be pushed on 
            a macroscopic lock.  It also implements RecyclingFactor for its private event args to reduce
            overhead (and time).
            Usage:
                1. Choose a fileName, directoryPath for use for output.
                2. Set values to control if/when to flush buffer and perform write.
                    2a. MinimumLinesToWrite - must have at least this many lines in buffer to write.
                    2b. WriteDelaySecs - number of seconds to wait between check writing condition.
                3. Flushes buffers automatically when Stop is requested.
            </summary>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.#ctor(System.String,System.String,UV.Lib.Hubs.LogHub)">
            <summary>
            
            </summary>
            <param name="pathName">User provides directory base path (with trailing \\).</param>
            <param name="fileName"></param>
            <param name="logToUse"></param>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.RequestEnqueue(System.String)">
            <summary>
            Users call this function to push a line to write onto queue.
            Note that the order that requests are received, they are processed.
            </summary>
            <param name="aLineToWrite"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.RequestCopyTo(System.String,System.String)">
            <summary>
            Requests that the current drop file be copied to specified directory/filename.
            (If either of these strings are string.Empty, then the current value is used;
            that is, if you want to save the current drop file named, say, "Drop.txt" into a directory
            called "C:\\Archive\\" with the same file name, call with arguments ("C:\\Archive\\",string.Empty)
            </summary>
            <param name="targetPath">Archival directory path (with trailing "\\")</param>
            <param name="targetFileName">Archival file name.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.RequestCopyAllFiles(System.String,System.String)">
            <summary>
            Request that all files in local path (that contain the substring pattern provided) are copied to the
            target path directory.
            </summary>
            <param name="targetPath">has trailing "\\"</param>
            <param name="fileSubstringPattern"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.GetRequest(UV.Lib.IO.Drops.DropQueueWriterRequestType)">
            <summary>
            This method gives the caller a eventarg object to use.  It may be new
            or recycled from previous usage.
            </summary>
            <param name="requestType"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.ProcessFlushNow">
            <summary>
            Force a write of the contents of the message queue to the output file now.
            </summary>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.ProcessCopyTo(UV.Lib.IO.Drops.DropQueueWriterEventArgs)">
            <summary>
            
            </summary>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriter.ProcessCopyAllFiles(UV.Lib.IO.Drops.DropQueueWriterEventArgs)">
            <summary>
            Copies all files in the local Path (that match a given filename pattern) to
            another path.
            </summary>
            <param name="eventArgs"></param>
        </member>
        <member name="M:UV.Lib.IO.Drops.DropQueueWriterEventArgs.Clear">
            <summary>
            Clear all information stored during last use.
            </summary>
        </member>
        <member name="T:UV.Lib.IO.Xml.Node">
            <summary>
            This is a holding object for the XML handling libraries.  A node is a 
            stand-in for a object that has been extracted from an XML file.
            As a stand-in, its name will be the name of the true object that it represnents.
            </summary>
        </member>
        <member name="M:UV.Lib.IO.Xml.Node.Stringify">
            <summary>
            Since A Node object is a "stand-in" for a real object, we usually don't want to 
            convert a Node into a string.  (If we did we would call the usual Stringifiable.Stringify( obj ).)
            This method will create a string for the object that the Node is standing in for.  That is, 
            the start tag will contain the object name stored in Node.Name, not the real class name for the
            node itself.
            </summary>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.MarketHubs.MarketHub">
            <summary>
            The MarketHub is abstract; it cannot be instantiated since it lacks a specific way to connect
            to the outside world.  Other classes that know how to communicate with a market API will inherit 
            this class.  
            The market implementation that inherits MarketHub must:
                1) Implement: void HubEventHandler(EventArgs[] eventArgList)
                    Specifically handle each variant of MarketHubRequest, and any other events generated by the API.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.TryGetInstrumentDetails(UV.Lib.Products.InstrumentName,UV.Lib.Products.InstrumentDetails@)">
            <summary>
            Called by an outside thread to try and get the details of a given instrument name.
            </summary>
            <param name="instrName"></param>
            <param name="instrDetails"></param>
            <returns>false if failed</returns>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.Connect">
            <summary>
            MarketHubs (and others) that communicate with the outside world have a two-layered 
            start up routine.  
            First, they are created and Start() is called. This begins their 
            internal thread and allows them to process requests. 
            Second, the function Connect() is called, this initializes the connection 
            to the outside world.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.RequestMarketServers">
            <summary>
            There may be more than one market server (or gateway) associated with this market hub.
            We can request all known servers available.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.RequestProducts(System.Collections.Generic.List{UV.Lib.Products.Product})">
            <summary>
            Request info about the provided products.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.RequestProducts(System.String)">
            <summary>
            Alternatively request all products with just an exchange name.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.RequestProducts(UV.Lib.Products.Product)">
            <summary>
            request information about a single product
            </summary>
            <param name="product"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.RequestInstruments(UV.Lib.Products.Product)">
            <summary>
            There may be more than one instrument associated with a product (such as with
            future instruments with differing expirations), request all information about a specific product family.
            </summary>
            <param name="product">The product family to request all instruments for.</param>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.Start">
            <summary>
            Called by an external thread. 
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.RequestStop">
            <summary>
            Called by an external thread. 
            Implements the HubBase abstract method.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.TryCreateNewBook(UV.Lib.Products.InstrumentName)">
            <summary>
            Called by the class that implements the market API when it wants to 
            create a new market book usually just before it subscribes to the instrument at the exchange.
            Then we it receives mkt update for this instrument, it can use the instrument lookup table to 
            see which book its in.
            </summary>
            <param name="instr"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.TryAddInstrumentDetails(UV.Lib.Products.InstrumentName,UV.Lib.Products.InstrumentDetails)">
            <summary>
            Hub thread calls to try and add instrument details to the dictionary table.
            </summary>
            <param name="instrName"></param>
            <param name="instrDetails"></param>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.OnMarketStatusChanged(System.Collections.Generic.List{System.String})">
            <summary>
            This triggers the MarketStatusChanged event.  Subscribers will receive 
            the names of the affect markets.
            TODO: Right now, the event doesn't say whether the market is up/down.  Perhaps it should, 
            or do we require subscribers check its state using a lookup function?
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.OnProductFound(System.Collections.Generic.List{UV.Lib.Products.Product})">
            <summary>
            This method must be called by the class that inherits this.  It is triggered
            whenever new products are discovered at any exchange.  
            </summary>
            <param name="products"></param>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.OnInstrumentFound(System.Collections.Generic.List{UV.Lib.Products.InstrumentName})">
            <summary>
            This should be triggered by the implementing market hub whenever a 
            new Instrument appears in the Instrument Details lists.  That is, 
            when we first learn about the details of a new instrument.
            </summary>
            <param name="instruments"></param>
        </member>
        <member name="M:UV.Lib.MarketHubs.MarketHub.OnMarketInstrumentFound(System.Collections.Generic.List{UV.Lib.Products.InstrumentName})">
            <summary>
            This should be called after a new instrument book is created, 
            and after it has an initial market set.
            </summary>
            <param name="instruments"></param>
        </member>
        <member name="P:UV.Lib.MarketHubs.MarketHub.LocalTime">
            <summary>
            This allows a simulated market to provide the current time by
            overloading this property.
            </summary>
        </member>
        <member name="E:UV.Lib.MarketHubs.MarketHub.MarketStatusChanged">
            <summary>
            Reports when markets go "up" or "down."
            </summary>
        </member>
        <member name="E:UV.Lib.MarketHubs.MarketHub.FoundResource">
            <summary>
            Reports when any new product, instrument, or market is discovered.
            </summary>
        </member>
        <member name="T:UV.Lib.MarketHubs.PriceLeg">
            <summary>
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.PriceLeg.Clone">
            <summary>
            Shallow clone method for fill object
            </summary>
            <returns>shallowly cloned Fill Object</returns>
        </member>
        <member name="T:UV.Lib.MarketHubs.RequestCode">
            <summary>
            Request code for MarketHubs.
            </summary>
        </member>
        <member name="T:UV.Lib.MarketHubs.Sims.SimMarketHub">
            <summary>
            This is a sim market hub.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.Sims.SimMarketHub.Start">
            <summary>
            This is called after all services exist, but before any services is connected.
            </summary>
        </member>
        <member name="M:UV.Lib.MarketHubs.Sims.SimMarketHub.HubEventHandler(System.EventArgs[])">
            <summary>
            This central event processing method.
            </summary>
            <param name="eventArgList"></param>
        </member>
        <member name="M:UV.Lib.MarketHubs.Sims.SimMarketHub.PlayNextMarketUpdate(System.UInt32)">
            <summary>
            Advance all timeseries until they are at (the end of) uTimeNow.
            </summary>
            <param name="uTimeNow"></param>
        </member>
        <member name="M:UV.Lib.MarketHubs.Sims.SimMarketHub.SetSimulatedTime(System.DateTime)">
            <summary>
            Sets the internal sim clock time to dt.
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.Order.GetNextId">
            <summary>
            Static function that returns next unused Id
            number for an order.  Each session, the order id
            numbers restart at zero.
            </summary>
            <returns></returns>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.PricePending">
            <summary>
            The elemental value is the integer IPrice. 
            This provides a double-valued price. This is the pending
            value, not yet confirmed by the market.
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.PriceConfirmed">
            <summary>
            Confirmed price of order.
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.OriginalQtyPending">
            <summary>
            The qty requested for the order
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.OriginalQtyConfirmed">
            <summary>
            This is the current confirmed qty of the order
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.WorkingQtyConfirmed">
            <summary>
            signed current working qty of order confirmed working.
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.WorkingQtyPending">
            <summary>
            signed current working qty of order pending confirmation
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.ExecutedQty">
            <summary>
            signed qty this order OR the parent order (if a cancel/replace occured) was filled on.
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.StopPricePending">
            <summary>
            The elemental value is the integer IPrice. 
            This provides a double-valued price. This is the pending
            value, not yet confirmed by the market.
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.Order.StopPriceConfirmed">
            <summary>
            Confirmed price of order.
            </summary>
        </member>
        <member name="T:UV.Lib.OrderBooks.OrderBook">
            <summary>
            Orderbook for a single instrument.
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.TryAdd(UV.Lib.OrderBooks.Order,System.Boolean)">
            <summary>
            Adds new order to the order book. 
            </summary>
            <param name="newOrder"></param>
            <param name="addToDeadBook"></param>
            <returns>False if the add failed.</returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.TryGet(System.Int32,UV.Lib.OrderBooks.Order@,System.Boolean)">
            <summary>
            This returns the order object *without* removing it from its location.
            </summary>
            <param name="orderId"></param>
            <param name="order"></param>
            <param name="includeDeletedBook"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.TryDelete(System.Int32)">
            <summary>
            This can fail only if the orderId is not found.
            This should only be called when we are confirmed dead!
            </summary>
            <param name="orderId"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.GetOrdersByRank(System.Int32,System.Int32,System.Collections.Generic.List{UV.Lib.OrderBooks.Order}@)">
            <summary>
            Searches for all orders that are rank R away from market
            and loads them into orders list (without removing them from book).
            Rank R=0 is the price level that is closest to the other side of the market, 
            most likely to be filled!
            </summary>
            <param name="side"></param>
            <param name="rank"></param>
            <param name="orders"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.GetOrdersBySide(System.Int32,System.Collections.Generic.Dictionary{System.Int32,UV.Lib.OrderBooks.Order}@)">
            <summary>
            Searches for all order on a given side of the market. Handing them 
            back to the caller in a dictionary.
            </summary>
            <param name="side"></param>
            <param name="orders"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.GetOrdersByUserDefinedTag(System.Int32,System.Int32,System.Collections.Generic.List{UV.Lib.OrderBooks.Order}@)">
            <summary>
            Searches for al liver  orders on a given side of the market, 
            with a specific tag.
            </summary>
            <param name="side"></param>
            <param name="tag"></param>
            <param name="orders"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.Count(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.UpdateTotalWorkingQty">
            <summary>
            Caller would like to book to update its total working quantity for all live orders
            in a confirmed submitted state.
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.OnOrderFilled(UV.Lib.Fills.FillEventArgs)">
            <summary>
            After any order status updated and after we have already updated our quoting orders, 
            this event is fired first before all others.
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.OnOrderStateChanged(System.EventArgs)">
            <summary>
            After any order status change and after the order is updated in the book, 
            this event is triggered.  
            This event is only triggered for serious changes to the order state.
            Events include Reject, Cancel, and Fill
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderBook.OnOrderSubmitted(System.EventArgs)">
            <summary>
            After the order status is updated in the book and the 
            total working quanity of the book has been updated 
            this event is triggered for confirmed submitted 
            from the exchange.
            </summary>
            <param name="orderStatusEventArgs"></param>
        </member>
        <member name="T:UV.Lib.OrderBooks.OrderInstrument">
            <summary>
            This manages a collection of Orderbooks for a single InstrumentName.
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.#ctor(UV.Lib.Products.InstrumentName,UV.Lib.Products.InstrumentDetails)">
            <summary>
            Main constructor for Order Instrument.  
            </summary>
            <param name="instrumentName"></param>
            <param name="details"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.TryAddBook(UV.Lib.OrderBooks.OrderBook)">
            <summary>
            
            </summary>
            <param name="newOrderBook"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.TryAddOrder(System.Int32,UV.Lib.OrderBooks.Order)">
            <summary>
            Called by the OrderBookHub to add an order to book.
            If this order is added to book, we return true, which tells the
            OrderBookHub to truly submit the order to the exchange also.
            Additionally this will set the account for the order based on the account
            of the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.TryAddToDefaultBook(UV.Lib.OrderBooks.Order)">
            <summary>
            Called by the OrderBookHub to add an order to the default book.
            This is typically only done on start up when orders are found
            that aren't associated with any strategy and just need to be
            stored.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.TryGetOrder(System.Int32,UV.Lib.OrderBooks.Order@)">
            <summary>
            Called by the OrderBookHub to try and get a specific order
            </summary>
            <param name="orderID"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.TryDeleteOrder(System.Int32)">
            <summary>
            Called on confirmations only!
            Caller would like to try and delete an order.
            This move the order out of the "Live" collection
            and into the deleted orders collection. It also
            sets the state to Dead/Dead.
            </summary>
            <param name="orderID"></param>
            <returns>false if orderID isn't found</returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.GetAllOrderBooks(System.Collections.Generic.List{UV.Lib.OrderBooks.OrderBook}@)">
            <summary>
            Caller would like a list of all order books for this OrderInstrument
            </summary>
            <param name="orderBookList"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.TryProcessFill(UV.Lib.Fills.FillEventArgs)">
            <summary>
            Called by the execution listener when an order is filled.
            This method will update state, and send out events.
            </summary>
            <param name="fillEventArgs"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.OrderStateChanged(UV.Lib.OrderBooks.OrderEventArgs)">
            <summary>
            Called when an order is filled, rejected, or cancelled only
            </summary>
            <param name="orderEventArgs"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderInstrument.OrderSubmitted(UV.Lib.OrderBooks.OrderEventArgs)">
            <summary>
            Called when we get a confirmation for an orders submission
            </summary>
            <param name="orderEventArgs"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.OrderBooks.OrderPage">
            <summary>
            This is the component of the OrderBook that contains all orders 
            from ONE side of the market.  All orders herein are either BuySide, or SellSide etc.
            </summary>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.#ctor(System.Int32,UV.Lib.OrderBooks.OrderBook)">
            <summary>
            
            </summary>
            <param name="sideOfOrders">Each OrderPage contains either Buy/Sell orders</param>
            <param name="parentBook"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.TryAdd(UV.Lib.OrderBooks.Order)">
            <summary>
            Adds a copy of newOrder into this OrderPage.
            </summary>
            <param name="newOrder"></param>
            <returns>true, if successful.</returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.TryGetIPriceByRank(System.Int32,System.Int32@)">
            <summary>
            The price at a certain rank.
            </summary>
            <param name="rank">rank 0 is closest order to market, etc.</param>
            <param name="iPrice"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.TryMove(System.Int32,UV.Lib.OrderBooks.OrderPage)">
            <summary>
            
            </summary>
            <param name="orderId">Id of order to be moved.</param>
            <param name="toOrderPage">OrderPage to receive the order.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.ChangePrice(UV.Lib.OrderBooks.Order,System.Int32)">
            <summary>
            Given an order this method will change its price and 
            it IPriceLevel in the collections.
            </summary>
            <param name="orderToChange"></param>
            <param name="newIPrice"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.ChangePendingPriceLevel(UV.Lib.OrderBooks.Order,System.Int32)">
            <summary>
            Called internally once a lock is obtained only to deal with book keeping surrounding
            pending prices 
            </summary>
            <param name="orderToModify"></param>
            <param name="newIPrice"></param>
        </member>
        <member name="M:UV.Lib.OrderBooks.OrderPage.TryProcessFill(UV.Lib.Fills.FillEventArgs)">
            <summary>
            Caller would like to process a confirmed fill from the exchange
            False only if the order isn't found.
            </summary>
            <param name="fillEvent"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.OrderBooks.RequestCode">
            <summary>
            This enum provides internal request codes that should be processed 
            by any class implementing OrderBookHub.
            </summary>
        </member>
        <member name="T:UV.Lib.OrderBooks.SyntheticOrder">
            <summary>
            </summary>
        </member>
        <member name="P:UV.Lib.OrderBooks.SyntheticOrder.ExecutedQty">
            <summary>
            Synthetic Fill Qty.
            </summary>
        </member>
        <member name="T:UV.Lib.ParameterManagement.Parameter">
            <summary>
            TODO: make this stringifiable!
            </summary>
        </member>
        <member name="T:UV.Lib.ParameterManagement.ParameterEventArgs">
            <summary>
            Messages for updating, changing, broadcasting values of parameters
            </summary>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterEventArgs.DecodeMessage(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.Object}@)">
            <summary>
            Create message for encoding parameter key/value pairs.
            </summary>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterEventArgs.EncodeMessage(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Object},System.Text.StringBuilder@)">
            <summary>
            Message is "elements" separated by ElementDelims.
            Message come in two types only:
            1) comma delimited list of items.
                This option is acheived by passing a null for parameterValues, or passing in an empty list.
            2) comma delimited list of pairs of items of the format "KeyName=Value"
                This option must have equal count of the two lists.
            </summary>
            <param name="parameterNames"></param>
            <param name="parameterValues"></param>
            /// <param name="outMessage">Message is appended to this StringBuilder</param>
            <returns>true if message decoded successfully.</returns>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.#ctor(System.Object)">
            <summary>
            Creates a Parameter Manager and collects all the 
            </summary>
            <param name="objectWithParameters"></param>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.Add(UV.Lib.ParameterManagement.Parameter)">
            <summary>
            TODO: Can we check for uniqueness of name, and fix it?
            </summary>
            <param name="newParameter"></param>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.AddAll(System.Object)">
            <summary>
            TODO: Can we check for uniqueness of name, and fix it?
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.ProcessEvent(UV.Lib.ParameterManagement.ParameterEventArgs)">
            <summary>
            When object receives a ParameterEventArg from outside regarding its
            parameters managed by this class, the request is processed here.
            The eventArg is overwritten with the appropriate response.
            </summary>
            <param name="eventArg"></param>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.GetParameterValues(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.Object}@)">
            <summary>
            User provides list of parameter IDs and wants to know their current values.
            </summary>
            <param name="inputList">IDs of parameters</param>
            <param name="outputList">current values</param>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.GetParameterValues(System.String,System.Object@)">
            <summary>
            User provides name of single parameter, and if found returns the value.
            </summary>
            <param name="parameterName"></param>
            <param name="parameterValue"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.SetParameterValues(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Object})">
            <summary>
            User provides list of parameter IDs and wants to know their current values.
            </summary>
            <param name="paramNameList">IDs of parameters</param>
            <param name="paramValueList">current values</param>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.SetParameterValues(UV.Lib.ParameterManagement.Parameter,System.Object)">
            <summary>
            Provided a single parameter object, attempts to set its value to the paramValue object.
            </summary>
        </member>
        <member name="M:UV.Lib.ParameterManagement.ParameterManager.ConvertToObject(System.String,System.Type)">
            <summary>
            See: http://stackoverflow.com/questions/3965871/c-sharp-generic-string-parse-to-any-object
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Products.InstrumentDetails.#ctor(UV.Lib.Products.InstrumentName,System.String,System.Double,System.Double,System.Double,System.DateTime,UV.Lib.Products.ProductTypes)">
            <summary>
            Create Instrument Details for a given instrument.
            </summary>
            <param name="instr"></param>
            <param name="currency"></param>
            <param name="tickSize">Smallest price change possible of intsrument</param>
            <param name="multiplier">The multiplier * current price = notional value of contract.  (Multiplier = TickValue / TickSize)</param>
            <param name="executableTickSize"> Smallest possible increment to be filled in</param>
            <param name="expires"></param>
            <param name="type"></param>
        </member>
        <member name="M:UV.Lib.Products.InstrumentDetails.IsStandardInstrument(UV.Lib.Products.InstrumentName)">
            <summary>
            Called for futures only where we expect the series name to have some sort of date in it.
            This is mainly a way of filtering out instrument like "e-Brent Cal 14" and "e-Brent Q1"
            which are getting denoted as futures but have multiple instruments within.
            </summary>
            <param name="instr"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.Products.InstrumentName">
            <summary>
            This represents the name of a UNIQUE instrument.  
            Since this is a struct, we can not distiguish between two different instances of this object if
            they have the same Product and KeyName.
            Why is this useful?
                A: This struct is ideal for use in lookup tables since its will match another key (a different instance)
                as long as the product and KeyName are the same!
            </summary>
        </member>
        <member name="P:UV.Lib.Products.InstrumentName.IsEmpty">
            <summary>
            Returns true if this Instrument is the empty instrument.
            </summary>
        </member>
        <member name="P:UV.Lib.Products.InstrumentName.IsProduct">
            <summary>
            Returns true if the Instrument is trivially just its own product.
            This happens for Instruments that are alone in their product family, like perhaps a stock.
            Or, when we are using the InstrumentName to denote a whole family of instruments.
            </summary>
        </member>
        <member name="M:UV.Lib.Products.InstrumentNameComparer.Compare(UV.Lib.Products.InstrumentName,UV.Lib.Products.InstrumentName)">
            <summary>
            Orders instruments by: ProductType, Exchange, Product name, finally by Series name.
            </summary>
            <param name="nameA"></param>
            <param name="nameB"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.Products.InstrumentNameMapTable">
            <summary>
            This class represents a table to map InstrumentNames (Products) from one
            API to another.  For example, it has been used to reconcile the Ambre application 
            to RCG's clearing.  In this case, Ambre InstrumentNames are based on the names used
            in TT API.  Since RCG has their own naming convention for instruments and products, 
            we created an instance of this class to load itself from a file, and provide the 
            mapping from RCG to TTApi names.
            Features:
                1) It is able to load itself from a comma-delimited file.
                2) It allows addition pairs to be added to the table during runtime.
                3) It is able to save itself to a comma-delimited file.
                4) I plan to allow the mappings to be many-to-many.  This happens in the case
                    when two Ambre users trade the ten-year future on TTApi where the same instr
                    has two names CME.ZN (Future) and CBOT.ZN (Future).  (Clearing firms seem to 
                    have only ONE name for each instrument.)
            </summary>
        </member>
        <member name="M:UV.Lib.Products.InstrumentNameMapTable.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="filePath">Full path of file with table.</param>
        </member>
        <member name="M:UV.Lib.Products.InstrumentNameMapTable.TryFindMappings(UV.Lib.Products.InstrumentName,System.Collections.Generic.List{UV.Lib.Products.InstrumentName}@,System.Collections.Generic.List{UV.Lib.Products.InstrumentName}@,System.Collections.Generic.List{UV.Lib.Products.InstrumentName}@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="memberOfList1"></param>
            <param name="matchingMembersOfList2"></param>
            <param name="list1"></param>
            <param name="list2"></param>
            <param name="useExactMatch">false -> matching product part only</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Products.InstrumentNameMapTable.TryGetNewEntries(System.Collections.Generic.List{UV.Lib.Products.InstrumentName}@,System.Collections.Generic.List{UV.Lib.Products.InstrumentName}@)">
            <summary>
            If there are new entries in the mapping, then a true is returned and the new entries 
            are returned. 
            </summary>
            <param name="newEntries1"></param>
            <param name="newEntries2"></param>
            <returns></returns>
        </member>
        <member name="P:UV.Lib.Products.InstrumentNameMapTable.IsNewEntries">
            <summary>
            Indicates whether there are new entries since we loaded/saved table to file.
            </summary>
        </member>
        <member name="T:UV.Lib.Products.Product">
            <summary>
            This is a struct - so its a Value-type of variable.  Two instances of a product are equal if each of their
            elements is equal.
            The Equals() and GetHashCode() methods are overloaded so that two instances are equal
            as long as they both refer to the same logical product (but can be separate instances of this class).
            </summary>
        </member>
        <member name="M:UV.Lib.RTS.Requests.RequestBuilder(UV.Lib.RTS.IDinfo.RID,UV.Lib.RTS.IDinfo.FID,System.String,System.Int32)">
            <summary>
            Acceptable sets of arguments:
            1.  RID.ctr_req_load_ctr_symbol, FID.symbol, "ED"   gets all contracts with this symbol
            2.  RID.ctr_req_load_underlying_ctr_id, FID.underlying_contract_id, "116" gets all contracts/options
                based on that underlying contract.
            </summary>
            <param name="requestID"></param>
            <param name="fieldID1"></param>
            <param name="fieldValue1"></param>
            <param name="contextID"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.Sockets.Conversation">
            <summary>
            One instance of this class is created for each thread that is used 
            to READ on a socket.  Used to identify who the thread is talking to, 
            and whether we want him to disconnect.
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.Conversation.Close">
            <summary>
            Complete closing of the conversation and its socket clients.
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.Conversation.RequestClose">
            <summary>
            This is an attempt to allow outsiders to shut down the conversation, 
            even when the Conversation is sitting at a read block line.
            </summary>
        </member>
        <member name="T:UV.Lib.Sockets.SocketManager">
            <summary>
            Socket manager  
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.#ctor(UV.Lib.Sockets.SocketManager.ProcessMessage)">
            <summary>
            Main constructor for SocketManager.  A ProcessMessage delagate must be 
            provided to decipher incoming byte-wise messages into complete messages.
            The function also must return any trailing fragments of an incomplete 
            message (that may be part of the next forth-coming message).
            </summary>
            <param name="msgProcessingFunction">Message processing delegate.</param>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.#ctor">
            <summary>
            The basic constructor uses a default simple message processing delegate.
            The simple delegate splits messages into strings using the default MessageDelimiters.
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.StartServer(System.Int32,System.String)">
            <summary>
            Start a new socket-listener SERVER in this object.
            Called by external thread which is immediately released, but only 
            after a new thread is spawned to listen to incoming connection requests.
            TODO: 
                1) Need to test re-starting server.
                2) What is the correct choice for host.address to use?
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.StopServer">
            <summary>
            Stops the server, if its currently running, and closes all current conversations.
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.BeginStartServer">
            <summary>
            This is an asynchronous call, that is handed to the unique thread, 
            called the TcpListener thread.  The only task for this thread
            is to listen for incoming socket connections.
            
            It will do wait as long as the TcpListener is open and m_IsServer is true.
            To shut down the server, call StopServer().
            
            Each time we detect a new connection on the TcpListener, we collects the
            TcpClient and put it into a new Conversation object, and call Conversation.Start().
            This spawns a Conversation thread to talk to the client. The conversation 
            is processed within the method SocketManager.BeginConversation() (in this object)!
            </summary>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.TryConnect(System.Net.IPAddress,System.Int32,System.Int32@)">
            <summary>
            Called by an external thread, attempts to connect to a TCP server, and
            if successful, spawns a new Conversation to handle incoming messages.
            </summary>
            <param name="addr"></param>
            <param name="portID"></param>
            <param name="conversationID"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.BeginConversation(System.Object)">
            <summary>
            This is called by the Conversation thread created when we become connected
            to a socket.   This triggers the Connected event.
            When the conversation is complete, the Disconnected event is triggered, and 
            the thread falls out the bottom of the method and dies.  
            Each time a complete message is read from the buffer, this thread call OnMessageReceived event.
            </summary>
            <param name="aNewConversation">Converstation holds info about who we are talking with.</param>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.RemoveConversation(System.Int32)">
            <summary>
            Conversations attempt to remove themselves from the conversation
            lookup tables after they close.
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.Send(System.String,System.Int32)">
            <summary>
            Send a string message to already connected client.
            This can be called by external threads.
            </summary>
            <param name="message"></param>
            <param name="conversationId"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.SimpleMessageProcessor(System.String@,System.Collections.Generic.List{System.String}@,System.String@)">
            <summary>
            This is the default, simple message processor that assume all messages are terminated 
            by one of the special characters given in the array MessageTerminators.
            </summary>
            <param name="newMessage"></param>
            <param name="completeMessages"></param>
            <param name="unfinishedMessage"></param>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.OnMessageReceived(System.Int32,System.String)">
            <summary>
            This method is called each time a new incoming message is received
            thru the socket.  This is called by an internal thread.
            It is virtual and so can be over-riden by an inheriting class in order to 
            implement processing without events.
            </summary>
            <param name="id"></param>
            <param name="s"></param>
        </member>
        <member name="M:UV.Lib.Sockets.SocketManager.OnInternalMessage(System.String)">
            <summary>
            This method is called each time a new incoming message is received
            thru the socket.  This is called by an internal thread.
            It is virtual and so can be over-riden by an inheriting class in order to 
            implement processing without events.
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:UV.Lib.IO.Xml.Stringifiable">
            <summary>
            Tools to convert classes into XML strings.
            </summary>
        </member>
        <member name="M:UV.Lib.IO.Xml.Stringifiable.TryGetType(System.String,System.Type@)">
            <summary>
            Searches all currently loaded assemblies looking for a type with the matching FullName.
            There is a peculiarity that not all assemblies are loaded until they are needed, so 
            by the time this is called, one class from each assembly better had been loaded.
            To ensure assembly is loaded try: 
                typeof( AssemblyName.ClassName ).ToString();
            For example: typeof( Ambre.TTServices.MarketHubs.MarketHub ).ToString(); will load entire assembly "Ambre.TTServices"
            Once a new type is discovered, it is store in the above table.
            </summary>
            <param name="typeFullName"></param>
            <param name="type"></param>
            <returns>true if type was determined.</returns>
        </member>
        <member name="M:UV.Lib.IO.Xml.Stringifiable.Create(UV.Lib.IO.Xml.Node)">
            <summary>
            This is the new March 2013 approach.  It converts a node into a IStringifiable object.
            Nodes are created by the StringifiableReader object.
            </summary>
            <param name="node">a node to Create</param>
            <returns>the newly created object</returns>
        </member>
        <member name="M:UV.Lib.IO.Xml.Stringifiable.Stringify(UV.Lib.IO.Xml.IStringifiable,System.Collections.Generic.Dictionary{System.Type,System.String[]},System.Boolean)">
            <summary>
            Takes IStringifiable object and encodes it into an XML string.
            Attributes are obtained using IStringifiable.GetAttributes(), and sub-elements obtained
            using IStringifiable.GetElements().
            Use of Override Table:
                Optionally, these functions can be overridden for specific object Types by including a string[3] array
                for the object Type key.  The string[3]{"typeFullName","GetAttributeFuncName","GetElementFuncName"}.     
                The name of the type allows one object to pretend to be another.  And the latter two functions must be 
                found in the instance of the true object being called.
            Example of Usage:
                Create the override table:
                    overrideTable = new Dictionary(Type, string[])();
                Add the object to override, and the names of the new functions to call.
                overrideTable.Add(m_FillHub.GetType(), new string[] { string.Empty, "GetAttributesDrop", "GetElementsDrop" });         
                Then call this function:
                    string s = Stringify(m_FillHub,overrideTable);
            Improvements:
                Can this be generalized to serialize objects generally? (At least some of them?)        
            </summary>
            <param name="target">IStringifiable object to convert.</param>
            <param name="overrideFunctionTable">dictionary of functions use instead of default Stringifiable interface for given Type. </param>
            <param name="useNiceFormat"></param>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.IO.Xml.StringifiableReader">
            <summary>
            A filestream reader for IStringifiable objects.
            </summary>
        </member>
        <member name="M:UV.Lib.IO.Xml.StringifiableReader.ReadToEnd(System.Boolean)">
            <summary>
            Returns list of IStringifiable objects created from the entire XML file.
            </summary>
            <param name="createNode"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Xml.StringifiableReader.TryReadNext(UV.Lib.IO.Xml.IStringifiable@,System.Boolean)">
            <summary>
            Method attempts to read (as much XML as needed to create) the next ISerializable object in file stream.
            This methoc can be called repeatedly to obtain each successive object in file.  Returns a false at the end
            of the file stream.
            TODO: Implement reflective object creation.
            </summary>
            <param name="newObject">Newly created object</param>
            <param name="createNode">If call is to create stand-in pseudo node object in place of real one.</param>
            <returns>True signifies sucessful creation of one object, false if at end of file.</returns>
        </member>
        <member name="M:UV.Lib.IO.Xml.StringifiableReader.TryAddAttribute(System.String,System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Called to add a string into a attributes dictionary
            </summary>
            <param name="str"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Xml.StringifiableReader.TryAddAllAttributes(System.String,System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Called to search inch by inch of a string, and extract multiple attributes 
            and place them into a dictionary.
            TODO: 
                Fix this.  Its possible to be confused when the attribute keyword has a space between
                it and the equals sign!!!
            </summary>
            <param name="str"></param>
            <param name="attributes"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.IO.Xml.StringifiableReader.BackUpOneWord(System.String@,System.Int32@,System.Int32)">
            <summary>
            Starting at the location ptrEnd, we will back it up (decrement it)
            until its value is the index of the space immediately before word.
            Example:
                KEYWORD = SOME VALUES
               23456789ABC
            ptrEnd = B, then we want to back up thru A, and continue to back up
            until ptrEnd=2.
            Notes:
                1) This implementation is not fooled by spaces trailing the word.
                    Such spaces are skipped first.
            </summary>
            <param name="str"></param>
            <param name="ptrEnd"></param>
            <param name="ptrStart"></param>
        </member>
        <member name="M:UV.Lib.TaskHubs.TaskEventArg.TryGetNextUnsuccessfulChild(UV.Lib.TaskHubs.TaskEventArg@)">
            <summary>
            This returns the latest child in the list that is NOT a success, or
            it returns the last child regardless.
            </summary>
            <param name="currentChild"></param>
            <returns>True, if currentChild is not null</returns>
        </member>
        <member name="P:UV.Lib.TaskHubs.TaskEventArg.StartTime">
            <summary>
            Returns the StartTime of the Task.
            If this task has children, will return the later of either the 
            next Unsucessful child or its own StartTime.
            </summary>
        </member>
        <member name="T:UV.Lib.TaskHubs.TaskHub">
            <summary>
            A task hub is a task processing job consumer with its on thread.
            TaskEventArgs define the tasks to be performed.  These are expected
            to contain a string EventHandlerName of the EventHandler method
            that the job is to be passed to. 
            A class should inherit this as a base class and implemented whatever
            eventhandlers it wants to process.  A List of objects "Data" in the event
            args can be used to pass data from one task to the next.
            </summary>
        </member>
        <member name="M:UV.Lib.TaskHubs.TaskHub.HubEventHandler(System.EventArgs[])">
            <summary>
            The main event handler, called by the hub thread.
            </summary>
        </member>
        <member name="M:UV.Lib.TaskHubs.TaskHub.ProcessTask(UV.Lib.TaskHubs.TaskEventArg)">
            <summary>
            Processes tasks from user.
            </summary>
        </member>
        <member name="M:UV.Lib.TaskHubs.TaskHub.Timer_Elapsed(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            This event handler is called by a pool thread; keep it threadsafe!
            </summary>
        </member>
        <member name="T:UV.Lib.Utilities.Alarms.Alarm">
            <summary>
            Basic alarm clock that allows users to set time that they 
            want a call back.  They provide the time, delegate to call and
            the EventArg to be passed to them.
            This is thread safe.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.Alarms.Alarm.GetDefaultTime">
            <summary>
            Get the DateTime.
            </summary>
            <returns></returns>
        </member>
        <member name="T:UV.Lib.Utilities.ConvertType">
            <summary>
            This is a a type conversion utility.
            </summary>
        </member>
        <member name="T:UV.Lib.Utilities.empty">
            <summary>
            This is a template for classes.
            Never use amp symbol!
            </summary>
        </member>
        <member name="T:UV.Lib.IO.FilesIO">
            <summary>
            These are static and helper functions for common IO stuff I like.
            </summary>
        </member>
        <member name="M:UV.Lib.IO.FilesIO.GetTodaysLogDirAndClean(System.String,System.Int32)">
            <summary>
            baseLogPath = "C:\User\Log\" is the expected path.
            </summary>
            <param name="baseLogPath">The log path that new directories will be put into.</param>
            <param name="daysToKeepLogs">Number of days to keep previous dated directories.</param>
            <returns>Log dir for today "2012-May-08\\"</returns>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueue.Add(System.EventArgs)">
            <summary>
            Any thread can push onto this queue.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueue.ProcessNewEvents">
            <summary>
            When new fills are found in the InQueue, they are processed and pushed onto
            the working Queue here.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueue.Timer_CallBack(System.Object)">
            <summary>
            The thread that call this method is an arbitrary pool thread.
            </summary>
            <param name="stateInfo"></param>
        </member>
        <member name="T:UV.Lib.Utilities.EventWaitQueueLite">
            <summary>
            This class allows hubs to push events onto a queue that will be 
            resubmitted automatically at a specified later time.
            This is a simpler version of the EventWaitQueue. 
            (EventWaitQueue also tracks multiple failures automatically.)
            Usage:
                1) Create an instance of this object.  Setting parameters like
                the min seconds between resubmissions, if desired.
                2) Subscribe to the ResubmissionReady event, for a hub simply set
                    eventWaitQueueList.ResubmissionReady += new EventHandler( HubEventEnqueue );
                3) Then, push eventArgs onto the queue using 
                    eventWaitQueueList.AddPending( eventArg, 2 );
                   where 2 indicates the eventArg will be resubmitted in two seconds.
            TODO: 
                1) Can we set the timer to turn on/off depending on status of queue?
                2) Can we keep track of failures?
            Created: 19 November 2013
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueueLite.#ctor(UV.Lib.Hubs.LogHub)">
            <summary>
            
            </summary>
            <param name="aLog">Optional logging allowed.</param>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueueLite.AddPending(System.EventArgs,System.Int32)">
            <summary>
            Any thread can push onto this queue as an event to be resubmitted at later time.
            </summary>
            <param name="eventArg"></param>
            <param name="secsToWait"></param>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueueLite.ProcessNewPending">
            <summary>
            When new EventArgs are added to the InQueue, they are processed here
            and pushed onto internal pending Queue.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.EventWaitQueueLite.Timer_CallBack(System.Object)">
            <summary>
            The thread that call this method is an arbitrary pool thread.
            </summary>
            <param name="stateInfo"></param>
        </member>
        <member name="P:UV.Lib.Utilities.EventWaitQueueLite.PendingCount">
            <summary>
            Number of events in the pending queue.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.KeyPressMessageFilter.PreFilterMessage(System.Windows.Forms.Message@)">
            <summary>
            Implements IFilterMessage interface.
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Net.NistServices.GetInstance(System.Boolean)">
            <summary>
            For non-time-critical runs, the nist timer can be simply bypassed 
            by setting isConnectToNist = false.
            </summary>
            <param name="isConnectToNist">True to do contact nist, false bypasses everything.</param>
            <returns></returns>
        </member>
        <member name="P:UV.Lib.Net.NistServices.SystemTimeOffset">
            <summary>
            This timespan should be added to system time to be closer to NIST time.
            For example: 
            DateTime correctNowEstimate = (DateTime.Now).Add(SystemTimeOffset)
            </summary>
        </member>
        <member name="P:UV.Lib.Net.NistServices.Messages">
            <summary>
            Allows user thread-safe access to any messages or warnings that this 
            services encountered.
            </summary>
        </member>
        <member name="T:UV.Lib.Utilities.PositionBook">
            <summary>
            This object simply holds a list of the current fills for a *single contract* (or strategy, etc)
            and the associated fill prices.  The difference between this object and a simple "fill" book, 
            is that while a "fill book" might containt all fills (both longs and shorts) that were collected 
            throughout a day, this "position book" will cancel positions on opposite sides of the mkt; 
            at any given moment, this book will contain only long positions, or only short positions or be empty.
            For example, when it contains a collection of shorts, and the user calls the "Add" method with a 
            positive (long) fill qty, this long position will be cancelled against the pre-existing short positions.
            
            This book only contains the current "OPEN" positions, their quantities at each fill price. 
            The net position is summarized in TotalQty.
            
            Some of the public methods in this class take a "PriceIndex" argument.  This is different from
            then internal index (referred to herein as the List Index).  The Price index is a zero-based index
            where priceIndex = 0 is the WORST fill in the book, or "fill that is closest to the other side";  
            that is, for long positions, priceIndex=0 is the highest fill price!  For short position, it is 
            the lowest fill price.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="smallestPriceIncrement">The quoted size of a "tick"; for ED
                this is 0.50, for equities its 0.01 (penny).</param>
            <param name="dollarAmtOfSmallestPriceIncrement">The dollar amount of a trading UNIT 
                (not tick); for ED the dollar value per trading unit is $25, while for
                stocks the dollar value per trading unit (or "point") is $1.</param>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.Add(System.Int32,System.Double)">
             <summary>
            		Add a new fill to the list.
             Note:
            		Under normal circumstances price/SmallestPriceIncrement must be an integer.  
             However, in a simulator we might assign slippage trade costs that are *smaller*
             than the SmallestPriceIncrement.  In this case, we replace this fractional price
             fill with TWO fills at different prices such that the (average price) * qty is 
             unchanged.  In particular, a fill price p, qty q is filled as:
             
            		q * p = q *(1-a) * Fl(p)  + q * a * Ce(p)			a is fraction of fill given to higher price.
            
             then, a = ( p - Fl(p) ) / ( Fl(p) - Ce(p) ),
             
             where Fl(p) and Ce(p) are the floor and ceiling prices around p.
             The denominator above is simply SmallestPriceIncrement, p - Fl(p) / SmallestPriceIncrement
             is called the excessTickPrice.  This fill is thus broken down according to the group addition rule:
             
            		{p,q} -->   {Fl(p), (1-a)*q}	(+)		{Ce(p), a*q}
            		
             TODO:  Please confirm that the following works even for prices that are negative!!
             </summary>
             <param name="price">exchange-quoted price of fill.</param>
             <param name="quantity">Quantity filled at this price.</param>
             <returns>realized gain (in dollars), if any.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.Add(System.String)">
            <summary>
            Overloading that takes a string in the format: qty @ fillPrice; that is, 
            "+10 @ 35.5" for example.
            </summary>
            <param name="fillString"></param>
            <returns>realized gain (in dollars), if any.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.AddAll(System.String)">
            <summary>
            This takes the whole serialized string for this position book.
            It splits the position into individual fill strings and adds them to the book
            </summary>
            <param name="allPositionString"></param>
            <returns>realized gain (in dollars), if any.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.RemoveAt(System.Int32)">
            <summary>
            Allows the user to delete the position at his chosen index.
            </summary>
            <param name="priceIndex"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.RemoveAtListIndex(System.Int32,System.Int32)">
            <summary>
            This is a private utility.
            </summary>
            <param name="listIndex"></param>
            <param name="qtyToRemove"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.MakeCopy">
            <summary>
            This makes a deep copy of this instance of Position Book.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.MakeNewCombinedBook(UV.Lib.Utilities.PositionBook[],System.Double[])">
            <summary>
            This static function creates a new Book by "combining" the fills of two or more other books.
            This is done by matching fills, one at a time from the worst price level up to the best.
            The new book is created and its pointer is returned to the caller.
            </summary>
            <param name="book">Array of PositionBook objects.  These are not affected by this routine.</param>
            <param name="weight">double array containing relative weights to be assigned to fills.
            	For example; a spread of two books would have weights of (+1.0,-1.0). </param>
            <returns>new PositionBook that represents the implied position. </returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.CombineBooks(UV.Lib.Utilities.PositionBook[],System.Double[])">
            <summary>
            This method first clears all entries in this book instance, then reloads it with fills implied
            by combining the array of books[] passed to it.  This overloading does not touch the array of
            input books; they are left unchanged.  This overloading is useful for making "implied" books 
            from 
            </summary>
            <param name="book"></param>
            <param name="weight"></param>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.CombineBooks(UV.Lib.Utilities.PositionBook[],System.Double[],System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="book">array of books to be combined.</param>
            <param name="weight">weights to use when combining books.</param>
            <param name="removeFillsFromBooks">If true this method removes the fills from the original 
            	books that were combined into the final book.  In this way, the sum of the input books
            	and the resulting combined book are equivalent to the total number of fills.
            	</param>
            <param name="combineBestFillsFirst">
            	If true then the best fills are combined together to form the new book.  The usual behavior
            	is false, that the worst fills from both books are combined to form a bad fill.
            	</param>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.ClearAll">
            <summary>
            Clears all entries in this instance of Position Book.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.UnrealizedDollarGains(System.Double[])">
            <summary>
            Returns the current portfolio liquidation value marked-to-market assuming
            the liquidation is done actively (hitting/lifting market) and perfect 
            liquidity (elasticity).  
            </summary>
            <param name="activeMarketPrices">ActivePrice[0,1] two-vector. Price to fill liquidation at for BUYSIDE=0 and SELLSIDE=1.</param>
            <returns>Market value of our current position.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.UnrealizedDollarGains(System.Double)">
            <summary>
            This computes unrealized gains assuming a simple, single exit price, usually a midprice, 
            for all the positions.  This is useful for quick estimates, and for strategies whose PnL
            is small compared to the bid/ask spread.
            </summary>
            <param name="midPrices"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetPriceQtyArrays(System.Int32[]@,System.Double[]@)">
            <summary>
            	Converts the entire book into two out arrays.  These arrays are
            ordered in the usual manner with the "worst" price located at index 0.
            	
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetPriceQtyArrays(System.Int32[]@,System.Double[]@,System.Boolean)">
            <summary>
            Main entry point for this method.
            </summary>
            <param name="qtyArray"></param>
            <param name="priceArray"></param>
            <param name="orderBestFillFirst">true and the arrays are order so that the best fill
            	(lowest buy / highest sale) is listed at the start of the array.  Otherwise, the worst
            	fill is listed first. 
            	</param>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetQty(System.Int32)">
            <summary>
            Gets the signed qty of the position at the price index.
            </summary>
            <param name="priceIndex">position from inside the mkt.</param>
            <returns>signed quantity of position at this index in book.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetPrice(System.Int32)">
            <summary>
            See GetQty() for explanation.  This method returns the price associated with the
            qty returned by GetQty().
            </summary>
            <param name="priceIndex">See GetQty().</param>
            <returns>price of fill.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetQtyByPriceOrWorse(System.Double)">
            <summary>
            Returns the sum of quantities at the target price, and all
            worse price levels.  That is, for a long position the quatity
            returned is the sum of fills at the price level "price" and 
            all HIGHER price levels.
            </summary>
            <param name="price"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.ToString(System.Int32)">
            <summary>
            This returns a string representing the fill at the ith price level, 
            where i = priceIndex is counted from the worst fill price (priceLevel=0)
            to the best price priceLevel = (number of entries - 1).
            Output format is like "+5 @ 9645.5"
            </summary>
            <param name="priceIndex">User's index of a particular entry in the book.</param>
            <returns>a string denoting a fill and price.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.ToString">
            <summary>
            This returns a string that appends all fills in book.
            This string is the correct format to be passed into the .AddAll(string) method.
            </summary>
            <returns>a string denoting all fills and prices in list separated by verticle bars "|".</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.FromString(System.String,System.Int32@,System.Double@)">
            <summary>
            This converts string to a fill qty and price in format "+20 @ 9555.5", where
            the first number is an integer and the second is a double.  They are separated
            by an " @ ", note the blank spaces around the @-symbol.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetEventArgs">
            <summary>
            Returns the state of the position book.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.Add(System.Int32,System.Int32)">
            <summary>
            Internal utility for adding a qty/price position to the list.  Here, the price must be given 
            in terms of ticks, not dollars.
            </summary>
            <param name="quantity"></param>
            <param name="tickPrice"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.PriceIndexToListIndex(System.Int32,System.Int32)">
            <summary>
            This internal private utility takes an worst index and converts it to our internal index.
            </summary>
            <param name="priceIndex">Usually this runs from 0 (worst fill) to N-1 (best fill).</param>
            <param name="fillOrdering">+1 indicates usual ordering from worst to best fill, -1 indicates reverse order.</param>
            <returns>corresponding internal list index, or -1 if error.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.PositionBook.GetFillPriceQty(System.Int32,System.Int32@,System.Double@)">
            <summary>
            Returns the price of the ith fill.
            </summary>
            <param name="listIndex">index (base 0) of the fill to be returned.</param>
            <param name="qty">Qty to of the ith fill.</param>
            <param name="price"></param>
            <returns>price of the ith fill.</returns>
        </member>
        <member name="P:UV.Lib.Utilities.PositionBook.Count">
            <summary>Gets the total number of unique positions.</summary>
        </member>
        <member name="P:UV.Lib.Utilities.PositionBook.RealizedDollarGains">
            <summary>
            This property gets the dollar amt of gains realized thus far.
            This value depends on the variable "DollarPerPoint" being properly set.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.#ctor">
            <summary>
            Empty default constructor -- not used in a static class.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.IsNearEqual(System.Double,System.Double,System.Double)">
            <summary>
            simple way to compare two doubles within an acceptable fractional
            tolerance.  Typically something very small like .0001.
            </summary>
            <param name="dbll"></param>
            <param name="dbl2"></param>
            <param name="fractionalTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.Heaviside(System.Double)">
            <summary>
            	The Heaviside "Theta" function:   
            		Theta(x) = +1	if x > 0, 
            					0	otherwise.		
            					
            	Note: I choose to use Theta(x=0) = 0, so that the support 
                for this function is the *open* set, x > 0.  This is a critical
                property if one is to use this function for a logical switch.
            	The form I use is
            	
            	Theta(x) = ( sign(x)^2  + sign(x) )/2
            					
            	Derivation: Recall the function Math.sign(x) = {sign of x, or zero when x = 0}.
            	Using the fact that s(x)^2 = +0 if x = 0, and +1 otherwise, we can write
            		Theta(x) = (1 + s(x))/2 - (1 - s(x)^2 ) / 2  
            				 =  1 + ( s(x) - s(x)^2 )/2 .
            </summary>
            <param name="x">Independent variable.</param>
            <returns>The heaviside Theta ("step") function; 
                f(x) = +1, if x > 0, and f(x) = 0, for all other x.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.Heaviside(System.Double,System.Double)">
            <summary>
            This generalization of the the Canonical Heaviside function, is 
            defined as
                    Theta(x, w) =   0       if x is less than or equal to zero, 
                                    +1      if x >= w, 
                                    x/w     if x is on (0,w) domain.
            Thus, its a step function with a linear transition period between x=0 
            and +w.
            
            </summary>
            <param name="x">function argument</param>
            <param name="width">width of transition region, zero or non-zero.
                For zero width, the result is the canonical heaviside function.</param>
            <returns>Heaviside generalization, with finite width.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.TruncateToDomain(System.Double,System.Double,System.Double)">
            <summary>
            This function returns x if x in the domain [a,b]. 
            If x is below this domain, function returns lower.
            If x is above this domain, function returns upper; that is, 
            
            					a		if x less than a, 
            T(x,a,b)	=		x		if x is greater than a, less than b, 
            					b		if x is greater than b.   
            
            	Note: Returns upper when upper is less than lower. (This is junk)
            </summary>
            <param name="x">value to be truncated</param>
            <param name="lower">lower bound of domain</param>
            <param name="upper">upper bound of domain</param>
            <returns>new value x' that is in [lower,upper].</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.MountainRange(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            	Consider the piece-wise linear function y(E) such that it looks like the jagged mountain top.
            This function does allow for a step-like behavior at the first region, then it is continuous although
            not differentiable at the boundaries.
            
            				= 0															for E in (-infty,x0),
            				= h0 + (E-x0) * (h1-h0)/(x1-x0),							for E in (x0,x1),
            				.
            				.
            				.
            				= h_i + (E-x_i) * (h_{i+1} - h_{i}) / (x_{i+1} - x_{i}),	for E in (x_i, x_{i+1}),
            				.
            				.
            				= h_{n-1}													for E in (x_{n-1}, +infty).
            				
            The user must supply the n-dimensional vectors x[] and height[].
            The simple version is here explicitly, 
            </summary>
            <param name="E"></param>
            <param name="x0"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="h1"></param>
            <param name="h2"></param>
            <param name="lastResult">If last result > 0 then turn on historesis effect.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.Skyline(System.Double,System.Double[],System.Double[],System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="nodes">nodes = {x_i}</param>
            <param name="functionValues">Value of function at nodes g_i = g(x_i).</param>
            <param name="interpolationOrder"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.GetFloor(System.Double,System.Double[])">
            <summary>
            GetFloor() returns the index i of first array element nodes[i] 
            that is less than the given value x, and nodes[i+1] is greater than.
            GetFloor() returns:
            	
             	smallest i >=0,  s.t. nodes[i+1] > x > nodes[i]   
            or
            	i=-1, if no such i exists.
            	
            Notes: 
            1)	If the elements of nodes[] are monotonic increasing with i 
            	(that is, nodes[i+1] > nodes[i] for all i),
            	then this is just the usual definition of a floor function.  It returns 
            	the value immediately below the argument x.
            2)  However, if elements of nodes[] are not monotonic increasing then 
            	this returns largest index i s.t. x >= {nodes[j] for all j LE i}.
            
            </summary>
            <param name="x">point of interest</param>
            <param name="nodes">nodes[i]</param>
            <returns>
                index i  s.t. (x-x_j) >= 0 for all j less than or equal to i .
            </returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.IsZeroVector(System.Int32[])">
            <summary>
            	Given a single-dimensional array, this routine checks to see if any
            elements are non-zero.  It returns a true if ALL elements are zero.
            </summary>
            <param name="x">single-dimensional column vector.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.RoundPriceSafely(System.Double,System.Int32,System.Double)">
            <summary>
            	This method takes a price and rounds it to the SAFER tick price. Here, "safer"
            	means the price is rounded further away from the market. Therefore, sell side prices
            	are rounded up, and buy prices are rounded down to the nearest ticks.
            	
            	In general, a sloppy price can be writen as an exact price with an small error "eps", 
            			price = iPrice * minTickSize	+  eps
            	where iPrice is an integer, and  minTickSize > eps.  Error is smaller than eps.  Then, 
            	we want to return the safer trade price of 
            	
            		(iPrice + Theta[eps] )*minTickSize			for Sells,
            		
            		(iPrice - Theta[-eps])*minTickSize			for Buys.
            		
            	This formula says 
            		for Sells: if eps > 0, then we will add another tick to the price.
            		for Buys: if 0 > eps, then we lower the price by another tick.
            		
            	Using the above relation for the price, we find that (since tickSize > |eps|)
            		iPrice = Round(  price / minTickSize )
            		eps = price - iPrice * minTickSize
            	
            </summary>
            <param name="price">imperfect price to round to nearest (safe) tick price.</param>
            <param name="mktSideSign">Selling price = -1, Buying prices = +1</param>
            <param name="minTickSize">0.5 for ED.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.IsPriceEqual(System.Double,System.Double,System.Double)">
            <summary>
            Simple Check to See if two prices are equal
            </summary>
            <param name="price1"></param>
            <param name="price2"></param>
            <param name="tickSize"></param>
            <returns> bool </returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.Combination(System.Int32,System.Int32)">
            <summary>
            This function is the classic combination function:  The number of ways from 
            "n" given objects one can choose r of them.  In other words this gives the numbers 
            in Pascals triangle.  That is, (n r) gives the rth vaule of the nth row (where both 
            n and r start at zero:
            					 r=0,  r=1, r=2, etc
            n=0					1	  /    /
            n=1				1		1     /
            n=2			1		2		1
            n=3		1		3		3		1
            n=4	1		4		6		4		1
            etc.				
            
            if r less than n/2, then we compute  (n r) = ( n!/(n-r)! )  / r! = Fact(n,n-r) / Fact(r,0)
            if r >= n/2 then we compute (n r) = (n!/r!) / (n-r)! = Fact(n,r)/Fact(n-r,0).  This helps 
            cancel out the largest numbers first using Fact(n,r) when n and r are large.
            
            </summary>
            <param name="n">total number of objects n>=0.</param>
            <param name="r">number of objects to choose r>0.</param>
            <returns>Number of combinations (n r)</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.Factorial(System.Int32)">
            <summary>
            Return n!, the factorial of n, where n! = n*(n-1)*(n-2)*....(2)*(1).
            </summary>
            <param name="n">an integer.</param>
            <returns>n!</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.Factorial(System.Int32,System.Int32)">
            <summary>
            Overload for factorial, this returns n!/r!.  The ways its computed is by iteration.
            Fact(n,r)	= (n)(n-1)(n-2)(n-3) . . . (n-(r-3))(n-(r-2))(n-(r-1))		= n!/r!
            			
            				|	n Fact(n-1,r)		if (n>r), 
            			=	|
            				|	1					otherwise.
            </summary>
            <param name="n">a positive integer.</param>
            <param name="r">another positive integer.</param>
            <returns>The ratio (n! / r!)</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.AlphaToPeriod(System.Double)">
            <summary>
            Converts Alpha to a integerized lookback period
            </summary>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.PeriodToAlpha(System.Int32,System.Int32)">
            <summary>
            Converts Period (lifetime) to an alpha for a give timeScale (update frequency)
            </summary>
            <param name="lifeTime"></param>
            <param name="timeScale"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.GetCompleteStrategies(System.Int32[],System.Double[])">
            <summary>
            	Given a portfolio and a vector of weights, this returns the signed number of 
            *complete* strategies that can be extracted from the position.  Associated with 
            this is the "excess portfolio" (not computed here).
            Note:
            1.	This routine does not change the values in position[]!
            This routine assumes there is only one strategy; i.e., S = S' = 1.
            </summary>
            <param name="position">portfolio in leg-space to be checked.</param>
            <param name="weights">weights in leg-space.</param>
            <returns>signed number of complete strategies that can be pulled out.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.GetCompleteStrategies(System.Int32[],System.Double[],System.Int32[]@)">
            <summary>
            	This overloading also returns sets an excess quantity.
            </summary>
            <param name="position"></param>
            <param name="weights"></param>
            <param name="excess"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.GetMaximalStrategies(System.Int32[],System.Double[])">
            <summary>
            	This is the complement method for GetCompleteStrategies().  This method returns the
            	maximal number of strategies implied from the portfolio[] handed to this routine.
            	For example:
            		Consider a butterfly strategy with weights  (1  -2  1).  If the 
            			position[] = (0  -2  0), 
            		then the maximal number of butterflies is Max_{leg}(  | position[leg] / w[leg] | }, 
            		and the sign of this is Sign(  position[leg]/w[leg] ).
            		In this case the number returned would be -1.
            		
            </summary>
            <param name="position">A portfolio from which the maximal number of strategies is
            	to be extracted.</param>
            <param name="weights">see above</param>
            <returns>The maximal number of strategies implied by this position[].</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.GetMaximalStrategies(System.Int32[],System.Double[],System.Int32[]@)">
            <summary>
            	This overloading also returns sets an excess quantity.
            </summary>
            <param name="position">see above</param>
            <param name="weights"></param>
            <param name="excess">see above</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.CalculateDripQty(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculate what our absolute value drip qty should be given based on our dripQty, totalQty (DesiredQTY), and our current positon.
            </summary>
            <param name="dripQty"></param>
            <param name="totalQty"></param>
            <param name="currentPos"></param>
            <returns>absolute value drip qty to work. 0 if not qty to be worked.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.MktSideToMktSign(System.Int32)">
            <summary>
            Given the "market side" (0 for buy, 1 for sell), this method returns the corresponding 
            +1 for buy, -1 for sell.
            Note: Assumes side=0 "bid" and side=1 "ask". In some places, Navaid has been known to use
            0 for asks and 1 for bids so be careful!
            </summary>
            <param name="side">side of market 0=bid, 1=ask.</param>
            <returns> +1 for buys / -1 for shorting </returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.MktSignToMktSide(System.Int32)">
            <summary>
            Given the "market sign" +1 for buys and -1 for sells, this method returns
            a 0 and 1, respectively.
            </summary>
            <param name="sign">market sign +1=bid, -1=ask.</param>
            <returns>
            	0 if sign is +1, 1 if sign is -1.
            </returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.MktSideToActiveMktSide(System.Int32)">
            <summary>
            This method when provided a particular trade BuySide or SellSide
            returns the "ActiveSide" value that should be handed to ActivePrice[side].
            For example:  Say a BuySide (side=0) trade that is active will be placed 
            at the OFFER (refered to as side=1).
            </summary>
            <param name="tradeSide">Buy (BuySide) or Sell (SellSide).</param>
            <returns>The side of the market corresponding to doing the
            desired trade actively.
            </returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.MktSignToString(System.Int32)">
            <summary>
            	Given the market sign (+1 bid/-1 ask), this returns the 
            string "B" or "S".
            </summary>
            <param name="sign"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.TryMatrixDecode(System.String,System.Object@)">
            <summary>
            This conversion matches the convention of matlab.
            If the encoded string passed in is a column or row vector, that is, 
            it contains either row delimiters or column delimiters (but not both), 
            then a single dimension double[] is returned.  There is no distinction
            herein between vectors and co-vectors.
            Usage:  1 0 0 ; 0 2 0 ; 0 0 3  -->		100
            										020
            										003
            This function can handle NON-rectangular matrices without complaining.  
            Caller is responsible for error checking.
            </summary>
            <param name="codedArray"></param>
            <param name="array"></param>
            <returns>Returns either double[] or double[][].</returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.MatrixEncode(System.Double[])">
            <summary>
            The inverse of MatrixDecode().
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.ExponentialDistrib(System.Double,System.Double)">
            <summary>
            Exponential Distribution
            http://mathworld.wolfram.com/ExponentialDistribution.html
            </summary>
            <param name="argX"></param>
            <param name="argLambda"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.OlsonTimeZoneToTimeZoneInfo(System.String)">
            <summary>
            Converts an Olson time zone ID to a Windows time zone ID.
            See http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html.
            </summary>
            <param name="olsonTimeZoneId">An Olson time zone ID. </param>
            <returns>
            The TimeZoneInfo corresponding to the Olson time zone ID, 
            or null if you passed in an invalid Olson time zone ID.
            </returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.SecondsFromMidnightTimeSpan(System.Int32)">
            <summary>
            From seconds from midnight creates a timespan object
            </summary>
            <param name="secondsFromMidnight"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.TryGetMonthCode(System.Int32,System.String@)">
            <summary>
            No error checking is performed.
            </summary>
            <param name="monthNumber">1=Jan,...,12=Dec</param>
            <param name="monthCode"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.TryConvertMonthYearToCodeY(System.String,System.String@)">
            <summary>
            Try and convert a Month Year ie 'Dec13' or 'Dec3' to a month code and single digit year format
            ie 'Z3'
            </summary>
            <param name="MonthYear"></param>
            <param name="codeYear"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.TryConvertMonthYearToCodeYY(System.String,System.String@)">
            <summary>
            Try and convert a Month Year ie 'Dec13' or 'Dec3' to a month code and two digit year format
            ie 'Z13'
            </summary>
            <param name="MonthYear"></param>
            <param name="codeYear"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.QTMath.GetBaseSixtyDecode(System.Char)">
            <summary>
            returns -1 on error.
            </summary>
            <param name="codedBaseSixtyValue"></param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.RecycleFactory`1.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.RecycleFactory`1.#ctor(System.Int32)">
            <summary>
            Constructor that allows initial creation of storage of objects.
            </summary>
            <param name="initialNumberOfItems"></param>
        </member>
        <member name="M:UV.Lib.Utilities.RecycleFactory`1.Get">
            <summary>
            Recover a previously used object from storage, or create a new one.
            This version breaks the process into two steps:
                1. Try to get a recycled object from storage, or if that fails
                2. Create a new object.
            This way, each step in the process can be overriden by a subclass.
            </summary>
            <returns>T object ready for use.</returns>
        </member>
        <member name="M:UV.Lib.Utilities.RecycleFactory`1.Recycle(`0)">
            <summary>
            Put previously used item into store for recycling.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:UV.Lib.Utilities.RequestEventArg`1">
            <summary>
            Most hubs use an internal system of request eventArgs to push and process tasks.
            That is, external users will make requests of the hub by push an EventArg onto its queue
            which is then processed by the hub thread later.
            Typically, the tasks are enumerated by an enum, task like Startup, Shutdown, AddInstrument, etc.
            So, for convenience, these messages can be created using this specific factory.  
            Usage:
                1) The user need only provide its specific enum, and instantiate this recycling factory.
                2) Then, the RequestEventArgs are automatically created using the Get() method.
                3) When processing is complete, RequestEventArgs can be recycled using the Recycle() method.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:UV.Lib.Utilities.RequestEventArg`1.Equals(UV.Lib.Utilities.RequestEventArg{`0})">
            <summary>
            Compares two requests to see if they are the same in terms of their
            request type and data components.
            </summary>
            <param name="request"></param>
            <returns>false if different</returns>
        </member>
        <member name="M:UV.Lib.Utilities.RequestEventArg`1.Clear">
            <summary>
            A nice way to clean out the data. Useful when recycling these objects.
            </summary>
        </member>
        <member name="T:UV.Lib.Utilities.RequestFactory`1">
            <summary>
            Many hubs implementations usse a great deal of internal messaging, 
            its convenient to have recycling and a place to store requests that
            are waiting to be resubmitted later.
            This utility class creates new RequestEventArg and manages a pending
            list for those the hub wants to store for later submission.
            
            Features:
                1) Takes enum type "T".  
                    The enum should describe each of the specific requests that
                    the implementing hub requires. 
                    Usually these RequestEventArgs are private to the implementing hub.
                    
                2) Recycles RequestEventArgs.
                    * Everytime the hub has completed a request, the RequestEventArg should
                        be retuned to this object using the Recycle() method.
                    * When a RequestEventArg is needed, call method Get() and either 
                        a new one is created or one is taken from the recycled queue and 
                        returned to be reused.  
                    * Prior to being returned to user, each RequestEventArg is cleaned
                        completely using the RequestEventArg.Clear().  This returns it
                        to its default new state.
                        
                3) Threadsafe.
                    * Multiple threads can call Get() and Recycle() freely.
                    
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.RequestFactory`1.#ctor">
            <summary>
            Deafult Constructor for Request Factory
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.RequestFactory`1.#ctor(System.Int32)">
            <summary>
            Constructor allowing for intial creation of requests
            </summary>
            <param name="initialNumberOfItems"></param>
        </member>
        <member name="M:UV.Lib.Utilities.RequestFactory`1.Get(`0,System.Object[])">
            <summary>
            This overload is the usual way that one or more arguments
            are passed all at once.
            </summary>
            <param name="code"></param>
            <param name="args">array of objects to be added to Data.</param>
            <returns></returns>
        </member>
        <member name="M:UV.Lib.Utilities.RequestFactory`1.Get(`0,System.Collections.Generic.List{System.Object})">
            <summary>
            Overload copies objects from list.  List is not kept, 
            but the objects in it are taken and added to Data[].
            </summary>
            <param name="code"></param>
            <param name="objList">List of objects to load into Data</param>
            <returns></returns>
        </member>
        <member name="F:UV.Lib.Utilities.Strings.FormatDateTimeZone">
            <summary>
            
            Format for 5PM in Chicago -> "02-21-2013 17:29:54.145 -06:00"
            </summary>
        </member>
        <member name="M:UV.Lib.Utilities.Strings.TryParseDate(System.String,System.DateTime@,System.String)">
            <summary>
            This function exists because I keep forgetting how to set up all the extra Globalization crap.
            So, its here for convenience.
            </summary>
            <param name="s"></param>
            <param name="dateFormat"></param>
            <param name="datetime"></param>
            <returns>true if dateTime is created</returns>
        </member>
        <member name="T:UV.Lib.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:UV.Lib.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:UV.Lib.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
    </members>
</doc>
