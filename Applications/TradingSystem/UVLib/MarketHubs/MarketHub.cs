using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Text;


namespace UV.Lib.MarketHubs
{
    using UV.Lib.Hubs;
    using UV.Lib.BookHubs;

    using UV.Lib.Application;
    using UV.Lib.Products;
    using UV.Lib.Utilities;

    /// <summary>
    /// The MarketHub is abstract; it cannot be instantiated since it lacks a specific way to connect
    /// to the outside world.  Other classes that know how to communicate with a market API will inherit 
    /// this class.  
    /// The market implementation that inherits MarketHub must:
    ///     1) Implement: void HubEventHandler(EventArgs[] eventArgList)
    ///         Specifically handle each variant of MarketHubRequest, and any other events generated by the API.
    /// </summary>
    public abstract class MarketHub : BookHub, IService
    {

        #region Members
        // *****************************************************************
        // ****                     Members                             ****
        // *****************************************************************
        //
        // Internal infrastructure.
        protected ServiceStates m_ServiceState = ServiceStates.Unstarted;          // Current service state.
        protected RequestFactory<RequestCode> m_Requests = new RequestFactory<RequestCode>(100);


        // Lookup tables:
        //      - Lookup for InstrumentName --> Book[ID]
        protected ConcurrentDictionary<InstrumentName, int> m_InstrumentMarkets = new ConcurrentDictionary<InstrumentName, int>();
        private ConcurrentDictionary<InstrumentName, InstrumentDetails> m_InstrumentDetailsTable = new ConcurrentDictionary<InstrumentName, InstrumentDetails>();
        //
        //
        #endregion//Members


        #region Constructors
        // *****************************************************************
        // ****                     Constructors                        ****
        // *****************************************************************
        //
        public MarketHub(string name, string logDirectoryName, bool isShowLog)
            : base(name, logDirectoryName, isShowLog)
        {

        }
        //
        //       
        #endregion//Constructors


        #region Public Properties
        //
        //
        /// <summary>
        /// This allows a simulated market to provide the current time by
        /// overloading this property.
        /// </summary>
        public virtual DateTime LocalTime
        {
            get { return Log.GetTime();  }
        }
        //
        #endregion // public properties


        #region Public Lookup Methods
        // *****************************************************************
        // ****                     Public Methods                      ****
        // *****************************************************************
        // 
        public bool TryLookupInstrumentID(InstrumentName instrName, out int ID)
        {
            ID = -1;
            if (!m_InstrumentMarkets.TryGetValue(instrName, out ID))
                ID = -1;
            return (ID != -1);
        }//TryLookupInstrumentID()
        //
        //
        //
        //********************************************************
        //******           TryGetInstrumentDetails          ******
        //********************************************************
        /// <summary>
        /// Called by an outside thread to try and get the details of a given instrument name.
        /// </summary>
        /// <param name="instrName"></param>
        /// <param name="instrDetails"></param>
        /// <returns>false if failed</returns>
        public bool TryGetInstrumentDetails(InstrumentName instrName, out InstrumentDetails instrDetails)
        {
            return (m_InstrumentDetailsTable.TryGetValue(instrName, out instrDetails));
        }
        //
        //
        //
        public bool TryGetInstrumentDetails(List<InstrumentName> instrNameList, out List<InstrumentDetails> instrDetailsList)
        {
            InstrumentDetails detailsReturned;                                  
            instrDetailsList = new List<InstrumentDetails>();
            foreach (InstrumentName instrName in instrNameList)
            { // for every instrument, try and get its details
                if (TryGetInstrumentDetails(instrName, out detailsReturned))        // if we can get the details, add to list to return
                    instrDetailsList.Add(detailsReturned); 
            }
            if (instrDetailsList.Count != 0)
                return true;
            return false;
        }
        #endregion//Public Lookup Methods


        #region Public Request Methods
        // *****************************************************************
        // ****                     Public Methods                      ****
        // *****************************************************************
        /// <summary>
        /// MarketHubs (and others) that communicate with the outside world have a two-layered 
        /// start up routine.  
        /// First, they are created and Start() is called. This begins their 
        /// internal thread and allows them to process requests. 
        /// Second, the function Connect() is called, this initializes the connection 
        /// to the outside world.
        /// </summary>
        public virtual void Connect()
        {
        }
        // ****************************************************************
        // ****                 Request MarketServers()                ****
        // ****************************************************************
        /// <summary>
        /// There may be more than one market server (or gateway) associated with this market hub.
        /// We can request all known servers available.
        /// </summary>
        public virtual bool RequestMarketServers()
        {            
            return this.HubEventEnqueue( m_Requests.Get(RequestCode.RequestServers) );
        }
        //
        //
        // ****************************************************************
        // ****                     Request Products()                  ***
        // ****************************************************************
        /// <summary>
        /// Request info about the provided products.
        /// </summary>
        public virtual bool RequestProducts(List<Product> productList)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestProducts);
            foreach (object o in productList)
                request.Data.Add(o);
            return this.HubEventEnqueue(request);
        }
        /// <summary>
        /// Alternatively request all products with just an exchange name.
        /// </summary>
        public virtual bool RequestProducts(string mktServerName = "")
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestProducts);
            if (!string.IsNullOrEmpty(mktServerName))
                request.Data.Add(mktServerName);
            return this.HubEventEnqueue(request);
        }
        /// <summary>
        /// request information about a single product
        /// </summary>
        /// <param name="product"></param>
        /// <returns></returns>
        public virtual bool RequestProducts(Product product)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestProducts);
            request.Data.Add(product);
            return this.HubEventEnqueue(request);
        }
        //
        // *****************************************************************
        // ****                 Request Instruments()                   ****
        // *****************************************************************
        /// <summary>
        /// There may be more than one instrument associated with a product (such as with
        /// future instruments with differing expirations), request all information about a specific product family.
        /// </summary>
        /// <param name="product">The product family to request all instruments for.</param>
        public virtual bool RequestInstruments(Product product)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestInstruments);
            request.Data.Add(product);
            return this.HubEventEnqueue(request);
        }
        public virtual bool RequestInstruments(InstrumentName instrumentName)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestInstruments);
            request.Data.Add(instrumentName);
            return this.HubEventEnqueue(request);
        }
        //
        //
        // *****************************************************************
        // ****         Request Instrument Price Subscription           ****
        // *****************************************************************
        public virtual bool RequestInstrumentPriceSubscription(List<InstrumentName> instrumentList)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestInstrumentPriceSubscription);
            foreach (InstrumentName instrument in instrumentList)
                request.Data.Add(instrument);
            return this.HubEventEnqueue(request);
        }
        public virtual bool RequestInstrumentPriceSubscription(InstrumentName instrument)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestInstrumentPriceSubscription);
            request.Data.Add(instrument);
            return this.HubEventEnqueue(request);
        }
        //
        //
        //
        // *****************************************************************
        // ****      Request Instrument Time And Sales Subscription     ****
        // *****************************************************************
        public virtual bool RequestInstrumentTimeAndSalesSubscription(InstrumentName instrument)
        {
            RequestEventArg<RequestCode> request = m_Requests.Get(RequestCode.RequestInstrumentTimeAndSalesSubscription);
            request.Data.Add(instrument);
            return this.HubEventEnqueue(request);
        }
        //
        // *****************************************************************
        // ****                     Start()                             ****
        // *****************************************************************
        /// <summary>
        /// Called by an external thread. 
        /// </summary>
        public override void Start()
        {
            this.HubEventEnqueue(m_Requests.Get(RequestCode.RequestStart));
            base.Start();                   // This actually starts the thread.
        }//RequestStop().
        //
        //
        // *****************************************************************
        // ****                     RequestStop()                       ****
        // *****************************************************************
        /// <summary>
        /// Called by an external thread. 
        /// Implements the HubBase abstract method.
        /// </summary>
        public override void RequestStop()
        {
            this.HubEventEnqueue(m_Requests.Get(RequestCode.RequestShutdown));
        }//RequestStop().
        //
        //
        #endregion//Public Methods


        #region Protected Methods
        // *****************************************************************
        // ****                    Private Methods                      ****
        // *****************************************************************
        //
        //
        //
        // *************************************************************
        // ****                 TryCreateNewBook()                  ****
        // *************************************************************
        /// <summary>
        /// Called by the class that implements the market API when it wants to 
        /// create a new market book usually just before it subscribes to the instrument at the exchange.
        /// Then we it receives mkt update for this instrument, it can use the instrument lookup table to 
        /// see which book its in.
        /// </summary>
        /// <param name="instr"></param>
        /// <returns></returns>
        protected bool TryCreateNewBook(InstrumentName instr)
        {
            if (m_InstrumentMarkets.ContainsKey(instr))
            {
                Log.NewEntry(LogLevel.Minor, "TryCreateNewBook: {0} book already created.", instr);
                return false;
            }
            else
            {
                Market mktInstr = Market.Create(instr);
                int newID = this.AddInstrumentToBook(mktInstr);
                return m_InstrumentMarkets.TryAdd(instr, newID);
            }
        }//TryCreateNewBook()
        //
        //
        // *************************************************************
        // ****                     GetRequest()                    ****
        // *************************************************************
        // <summary>
        // This utility method uses the RequestFactory for request to create
        // and clear a request for new use.
        // </summary>
        // <param name="request"></param>
        // <returns></returns>
        /*
        protected MarketHubRequest GetRequest(RequestCode request)
        {
            MarketHubRequest eventArg = m_RequestFactory.Get();
            eventArg.Request = request;
            eventArg.Data.Clear();
            return eventArg;
        }//GetRequest()
        //
        //
        protected void RecycleRequest(MarketHubRequest requestToRecycle)
        {
            //m_RequestFactory.Recycle(requestToRecycle);
        }
        */ 
        //
        //
        // *************************************************************
        // ****          TryAddInstrumentDetails()                  ****
        // *************************************************************
        /// <summary>
        /// Hub thread calls to try and add instrument details to the dictionary table.
        /// </summary>
        /// <param name="instrName"></param>
        /// <param name="instrDetails"></param>
        protected bool TryAddInstrumentDetails(InstrumentName instrName, InstrumentDetails instrDetails)
        {
            if (m_InstrumentDetailsTable.TryAdd(instrName, instrDetails))           // try and add it 
                return true;
            if(!m_InstrumentDetailsTable.ContainsKey(instrName))                    // if we fail, and we don't already have this instrument...something went wrong!
                Log.NewEntry(LogLevel.Major, "MarketHub.TryAddInstrumentDetails: {0} Failed to Add to Instrument Details Dictionary.", instrName.ToString());
            return false;
        }
        //
        //
        #endregion // Protected Utility Methods


        #region Events and Triggers
        // *************************************************************
        // ****             Market Status Changed                   ****
        // *************************************************************
        /// <summary>
        /// Reports when markets go "up" or "down."
        /// </summary>
        public event EventHandler MarketStatusChanged;                          
        //
        /// <summary>
        /// This triggers the MarketStatusChanged event.  Subscribers will receive 
        /// the names of the affect markets.
        /// TODO: Right now, the event doesn't say whether the market is up/down.  Perhaps it should, 
        /// or do we require subscribers check its state using a lookup function?
        /// </summary>
        protected void OnMarketStatusChanged(List<string> marketNames)
        {
            if (MarketStatusChanged != null)
            {
                Log.BeginEntry(LogLevel.Minor, "OnMarketStatusChanged:");
                MarketStatusChangedEventArg newEventArg = new MarketStatusChangedEventArg();
                newEventArg.MarketNameList = new List<string>(marketNames);
                foreach (string mktName in marketNames)
                    Log.AppendEntry(" {0}", mktName);
                Log.EndEntry();
                MarketStatusChanged(this, newEventArg);
            }
        }// OnMarketStatusChanged()
        //
        //
        //
        //
        // ************************************************************
        // ****                 Found  Resource                    ****
        // ************************************************************
        /// <summary>
        /// Reports when any new product, instrument, or market is discovered.
        /// </summary>
        public event EventHandler FoundResource;
        /// <summary>
        /// This method must be called by the class that inherits this.  It is triggered
        /// whenever new products are discovered at any exchange.  
        /// </summary>
        /// <param name="products"></param>
        protected void OnProductFound(List<UV.Lib.Products.Product> products)
        {
            if (FoundResource != null)                                           
            {
                FoundServiceEventArg arg = new FoundServiceEventArg();
                arg.FoundProducts = products;
                FoundResource(this, arg);
            }
        }// OnMarketFoundResource()
        //
        /// <summary>
        /// This should be triggered by the implementing market hub whenever a 
        /// new Instrument appears in the Instrument Details lists.  That is, 
        /// when we first learn about the details of a new instrument.
        /// </summary>
        /// <param name="instruments"></param>
        protected void OnInstrumentFound(List<UV.Lib.Products.InstrumentName> instruments)
        {
            if (FoundResource != null)
            {
                FoundServiceEventArg arg = new FoundServiceEventArg();
                arg.FoundInstruments = instruments;
                FoundResource(this, arg);
            }
        }// OnMarketFoundResource()
        //
        /// <summary>
        /// This should be called after a new instrument book is created, 
        /// and after it has an initial market set.
        /// </summary>
        /// <param name="instruments"></param>
        protected void OnMarketInstrumentFound(List<UV.Lib.Products.InstrumentName> instruments)
        {
            if (FoundResource != null)
            {
                FoundServiceEventArg arg = new FoundServiceEventArg();
                arg.FoundInstrumentMarkets = instruments;
                FoundResource(this, arg);
            }
        }// OnMarketInstrumentFoundResource()
        //
        //
        protected void OnMarketBookCreated(List<UV.Lib.Products.InstrumentName> instruments)
        {
            if (FoundResource != null)
            {
                FoundServiceEventArg arg = new FoundServiceEventArg();
                arg.FoundInstrumentBooks = instruments;
                FoundResource(this, arg);
            }
        }// OnMarketBookCreatedResource()
        //
        //
        //
        #endregion//Market Events


        #region IService 
        // *****************************************************
        // ****                 IService                    ****
        // *****************************************************
        //
        public string ServiceName
        {
            get { return m_HubName; }
        }
        //
        public event EventHandler ServiceStateChanged;
        //
        //
        protected void OnServiceStateChanged(ServiceStates newState)
        {
            // Change the state
            ServiceStates prev = this.m_ServiceState;
            ServiceStateEventArgs eventArg = new ServiceStateEventArgs(this,newState,prev);
            this.m_ServiceState = newState;
            Log.NewEntry(LogLevel.Major, "MarketHub.ServiceStateChanged: {0}", eventArg);
            // Tell subscribers.
            if (ServiceStateChanged != null)
            {
                ServiceStateChanged(this, eventArg);
            }
        }//OnServiceStateChanged()
        //
        //
        //
        #endregion//IService implementation



    }//end class
}